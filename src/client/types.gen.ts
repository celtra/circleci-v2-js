// This file is auto-generated by @hey-api/openapi-ts

export type ClaimResponse = {
    audience?: Array<(string)>;
    audience_updated_at?: string;
    org_id: string;
    project_id?: string;
    ttl?: JSONDuration;
    ttl_updated_at?: string;
};

export type JSONDuration = string;

export type PatchClaimsRequest = {
    audience?: Array<(string)>;
    ttl?: JSONDuration;
};

export type BundleDiff = {
    created?: Array<(string)>;
    deleted?: Array<(string)>;
    modified?: Array<(string)>;
};

export type BundlePayload = {
    policies?: {
        [key: string]: (string);
    };
};

export type Decision = {
    enabled_rules?: Array<(string)>;
    hard_failures?: Array<Violation>;
    reason?: string;
    soft_failures?: Array<Violation>;
    status: string;
};

export type DecisionLog = {
    created_at?: string;
    decision?: Decision;
    id?: string;
    metadata?: {
        build_number?: number;
        project_id?: string;
        ssh_rerun?: boolean;
        vcs?: {
            branch?: string;
            origin_repository_url?: string;
            release_tag?: string;
            target_repository_url?: string;
        };
    };
    /**
     * policy-name-to-hash-map
     */
    policies?: {
        [key: string]: (string);
    };
    time_taken_ms?: number;
};

export type DecisionSettings = {
    enabled?: boolean;
};

export type Policy = {
    content?: string;
    created_at?: string;
    created_by?: string;
    name?: string;
};

export type PolicyBundle = {
    [key: string]: unknown;
};

export type Violation = {
    reason: string;
    rule: string;
};

export type context_project_restrictions_list = {
    items?: Array<{
        /**
         * UUID of the context
         */
        context_id?: string;
        /**
         * UUID of the restriction
         */
        id?: string;
        /**
         * Deprecated - For "project" restrictions read the project ID from
         * "restriction_value" instead.
         *
         * UUID of the project used in a project restriction.
         *
         * @deprecated
         */
        project_id?: string;
        /**
         * Contains a human-readable reference for the restriction. For
         * "project" restrictions this is the name of the project.
         *
         * May be null.
         *
         */
        name?: string;
        /**
         * Type of the restriction
         */
        restriction_type?: 'project' | 'expression';
        /**
         * Value used to evaluate the restriction
         */
        restriction_value?: string;
    }>;
    /**
     * Token that can be used to retrieve next page of results
     */
    next_page_token?: string | null;
};

export type project_settings = {
    advanced?: {
        /**
         * Except for the default branch, cancel running pipelines on a branch when a new pipeline starts on that branch.
         */
        autocancel_builds?: boolean;
        /**
         * Run builds for pull requests from forks.
         */
        build_fork_prs?: boolean;
        /**
         * Once enabled, we will only build branches that have associated pull requests open.
         */
        build_prs_only?: boolean;
        /**
         * When set to true, job re-runs with SSH debugging access will be disabled for the project.
         */
        disable_ssh?: boolean;
        /**
         * Run builds for forked pull requests with this project's configuration, environment variables, and secrets.
         */
        forks_receive_secret_env_vars?: boolean;
        /**
         * Free and Open Source. Enabling this grants additional credits, and lets others see your builds, both through the web UI and the API.
         */
        oss?: boolean;
        /**
         * Report the status of every pushed commit to GitHub's status API. Updates reported per job.
         */
        set_github_status?: boolean;
        /**
         * Enabling allows you to conditionally trigger configurations outside of the primary `.circleci` parent directory.
         */
        setup_workflows?: boolean;
        /**
         * Whether updating these settings requires a user to be an organization administrator. When disabled, updating settings can be done by any member.
         */
        write_settings_requires_admin?: boolean;
        /**
         * This field is used in conjunction with the `build_prs_only`, it allows you to specify a list of branches that will always triger a build. The value passed will overwrite the existing value.
         */
        pr_only_branch_overrides?: Array<(string)>;
    };
};

export type restriction_created = {
    /**
     * UUID of the project restriction
     */
    id?: string;
    /**
     * Deprecated - For "project" restrictions read the project ID from
     * "restriction_value" instead.
     *
     * UUID of the project used in a project restriction.
     *
     */
    project_id?: string;
    /**
     * Contains a human-readable reference for the restriction. For
     * "project" restrictions this is the name of the project.
     *
     * May be null.
     *
     */
    name?: string;
    /**
     * Type of the restriction
     */
    restriction_type?: 'project' | 'expression';
    /**
     * Value used to evaluate the restriction
     */
    restriction_value?: string;
};

/**
 * Type of the restriction
 */
export type restriction_type = 'project' | 'expression';

export type restriction_deleted = {
    /**
     * Response message
     */
    message?: string;
};

export type usage_export_job = {
    usage_export_job_id: string;
    state: 'created' | 'processing' | 'failed' | 'completed';
    start: string;
    end: string;
    /**
     * A list of pre signed urls that the client can use to download the results of a Usage Export.
     */
    download_urls: Array<(string)>;
};

export type state = 'created' | 'processing' | 'failed' | 'completed';

export type get_usage_export_job_status = {
    usage_export_job_id: string;
    state: 'created' | 'processing' | 'failed' | 'completed';
    /**
     * A list of pre signed urls that the client can use to download the results of a Usage Export.
     */
    download_urls: Array<(string)>;
    error_reason?: string;
};

/**
 * comma separated list of claims to delete. Valid values are "audience" and "ttl".
 */
export type ParameterClaims = string;

export type ParameterOrgID = string;

export type ParameterProjectID = string;

export type ParameterContext = string;

export type ParameterDecisionID = string;

export type ParameterOwnerID = string;

/**
 * An opaque identifier of a context.
 */
export type Parametercontext_id = string;

/**
 * An opaque identifier of a context restriction.
 */
export type Parameterrestriction_id = string;

/**
 * The `provider` segment of a project or org slug, the first of the three. This may be a VCS. For projects that use GitLab or GitHub App, use `circleci`.
 */
export type Parameterprovider = string;

/**
 * The `organization` segment of a project or org slug, the second of the three. For GitHub OAuth or Bitbucket projects, this is the organization name. For projects that use GitLab or GitHub App, use the organization ID (found in Organization Settings).
 */
export type Parameterorganization = string;

/**
 * The `project` segment of a project slug, the third of the three. For GitHub OAuth or Bitbucket projects, this is the repository name. For projects that use GitLab or GitHub App, use the project ID (found in Project Settings).
 */
export type Parameterproject = string;

/**
 * An opaque identifier of an organization.
 */
export type Parameterorg_id = string;

/**
 * An opaque identifier of a user.
 */
export type Parameteruser_id = string;

/**
 * The number of results per page.
 */
export type Parameterlimit = number;

/**
 * Specify what page of results to fetch.
 */
export type Parameternext_page_token = string;

/**
 * An opaque identifier of a group.
 */
export type Parametergroup_id = string;

/**
 * An opaque identifier of a project.
 */
export type Parameterproject_id = string;

/**
 * An opaque identifier of a usage export job.
 */
export type Parameterusage_export_job_id = string;

/**
 * The namespace that the Orb belongs to.
 */
export type Parameternamespace = string;

/**
 * The name of the requested Orb.
 */
export type Parametername = string;

/**
 * An opaque identifier of an orb.
 */
export type Parameterorb_id = string;

/**
 * The specific version of an Orb.
 */
export type Parameterversion = string;

/**
 * The namespace that the Orb belongs to.
 */
export type Parameternamespace_path = string;

/**
 * The name of the requested Orb.
 */
export type Parametername_path = string;

export type CreateContextData = {
    body?: {
        /**
         * The user defined name of the context.
         */
        name: string;
        owner: {
    /**
     * The unique ID of the owner of the context. Specify either this or slug.
     */
    id: string;
    /**
     * The type of the owner. Defaults to "organization". Accounts are only used as context owners in server.
     */
    type?: 'account' | 'organization';
} | {
    /**
     * A string that represents an organization. Specify either this or id. Cannot be used for accounts.
     */
    slug: string;
    /**
     * The type of owner. Defaults to "organization". Accounts are only used as context owners in server and must be specified by an id instead of a slug.
     */
    type?: 'organization';
};
    };
};

export type CreateContextResponse = {
    /**
     * The unique ID of the context.
     */
    id: string;
    /**
     * The user defined name of the context.
     */
    name: string;
    /**
     * The date and time the context was created.
     */
    created_at: string;
};

export type CreateContextError = {
    message?: string;
};

export type ListContextsData = {
    query?: {
        /**
         * The unique ID of the owner of the context. Specify either this or owner-slug.
         */
        'owner-id'?: string;
        /**
         * A string that represents an organization. Specify either this or owner-id. Cannot be used for accounts.
         */
        'owner-slug'?: string;
        /**
         * The type of the owner. Defaults to "organization". Accounts are only used as context owners in server.
         */
        'owner-type'?: 'account' | 'organization';
        /**
         * A token to retrieve the next page of results.
         */
        'page-token'?: string;
    };
};

export type ListContextsResponse = {
    items: Array<{
        /**
         * The unique ID of the context.
         */
        id: string;
        /**
         * The user defined name of the context.
         */
        name: string;
        /**
         * The date and time the context was created.
         */
        created_at: string;
    }>;
    /**
     * A token to pass as a `page-token` query parameter to return the next page of results.
     */
    next_page_token: string;
};

export type ListContextsError = {
    message?: string;
};

export type GetContextData = {
    path: {
        /**
         * ID of the context (UUID)
         */
        'context-id': string;
    };
};

export type GetContextResponse = {
    /**
     * The unique ID of the context.
     */
    id: string;
    /**
     * The user defined name of the context.
     */
    name: string;
    /**
     * The date and time the context was created.
     */
    created_at: string;
};

export type GetContextError = {
    message?: string;
};

export type DeleteContextData = {
    path: {
        /**
         * ID of the context (UUID)
         */
        'context-id': string;
    };
};

export type DeleteContextResponse = {
    /**
     * A human-readable message
     */
    message: string;
};

export type DeleteContextError = {
    message?: string;
};

export type ListEnvironmentVariablesFromContextData = {
    path: {
        /**
         * ID of the context (UUID)
         */
        'context-id': string;
    };
    query?: {
        /**
         * A token to retrieve the next page of results.
         */
        'page-token'?: string;
    };
};

export type ListEnvironmentVariablesFromContextResponse = {
    items: Array<{
        /**
         * The name of the environment variable
         */
        variable: string;
        /**
         * The date and time the environment variable was created.
         */
        created_at: string;
        /**
         * The date and time the environment variable was updated
         */
        updated_at: string;
        /**
         * ID of the context (UUID)
         */
        context_id: string;
    }>;
    /**
     * A token to pass as a `page-token` query parameter to return the next page of results.
     */
    next_page_token: string;
};

export type ListEnvironmentVariablesFromContextError = {
    message?: string;
};

export type DeleteEnvironmentVariableFromContextData = {
    path: {
        /**
         * ID of the context (UUID)
         */
        'context-id': string;
        /**
         * The name of the environment variable
         */
        'env-var-name': string;
    };
};

export type DeleteEnvironmentVariableFromContextResponse = {
    /**
     * A human-readable message
     */
    message: string;
};

export type DeleteEnvironmentVariableFromContextError = {
    message?: string;
};

export type AddEnvironmentVariableToContextData = {
    body?: {
        /**
         * The value of the environment variable
         */
        value: string;
    };
    path: {
        /**
         * ID of the context (UUID)
         */
        'context-id': string;
        /**
         * The name of the environment variable
         */
        'env-var-name': string;
    };
};

export type AddEnvironmentVariableToContextResponse = {
    /**
     * The name of the environment variable
     */
    variable: string;
    /**
     * The date and time the environment variable was created.
     */
    created_at: string;
    /**
     * The date and time the environment variable was updated
     */
    updated_at: string;
    /**
     * ID of the context (UUID)
     */
    context_id: string;
} | {
    /**
     * A human-readable message
     */
    message: string;
};

export type AddEnvironmentVariableToContextError = {
    message?: string;
};

export type GetProjectWorkflowsPageDataData = {
    path: {
        /**
         * Project slug in the form `vcs-slug/org-name/repo-name`. The `/` characters may be URL-escaped. For projects that use GitLab or GitHub App, use `circleci` as the `vcs-slug`, replace `org-name` with the organization ID (found in Organization Settings), and replace `repo-name` with the project ID (found in Project Settings).
         */
        'project-slug': string;
    };
    query?: {
        /**
         * The names of VCS branches to include in branch-level workflow metrics.
         */
        branches?: {
            [key: string]: unknown;
        };
        /**
         * The time window used to calculate summary metrics. If not provided, defaults to last-90-days
         */
        'reporting-window'?: 'last-7-days' | 'last-90-days' | 'last-24-hours' | 'last-30-days' | 'last-60-days';
        /**
         * The names of workflows to include in workflow-level metrics.
         */
        'workflow-names'?: {
            [key: string]: unknown;
        };
    };
};

export type GetProjectWorkflowsPageDataResponse = {
    /**
     * The unique ID of the organization
     */
    org_id?: unknown;
    /**
     * The unique ID of the project
     */
    project_id?: unknown;
    /**
     * Metrics and trends data aggregated for a given project.
     */
    project_data?: {
        /**
         * Metrics aggregated across all workflows and branches for a project.
         */
        metrics: {
            /**
             * The total number of runs, including runs that are still on-hold or running.
             */
            total_runs: number;
            /**
             * Total duration, in seconds.
             */
            total_duration_secs: number;
            /**
             * The total credits consumed over the current timeseries interval.
             */
            total_credits_used: number;
            success_rate: number;
            /**
             * The average number of runs per day.
             */
            throughput: number;
        };
        /**
         * Metric trends aggregated across all workflows and branches for a project.
         */
        trends: {
            /**
             * The trend value for total number of runs.
             */
            total_runs: number;
            /**
             * Trend value for total duration.
             */
            total_duration_secs: number;
            /**
             * The trend value for total credits consumed.
             */
            total_credits_used: number;
            /**
             * The trend value for the success rate.
             */
            success_rate: number;
            /**
             * Trend value for the average number of runs per day.
             */
            throughput: number;
        };
    };
    /**
     * A list of metrics and trends data for workflows for a given project.
     */
    project_workflow_data?: Array<{
        /**
         * The name of the workflow.
         */
        workflow_name: string;
        /**
         * Metrics aggregated across a workflow or branchfor a project.
         */
        metrics: {
            /**
             * The total credits consumed over the current timeseries interval.
             */
            total_credits_used: number;
            /**
             * The 95th percentile duration among a group of workflow runs.
             */
            p95_duration_secs: number;
            /**
             * The total number of runs, including runs that are still on-hold or running.
             */
            total_runs: number;
            success_rate: number;
        };
        /**
         * Trends aggregated across a workflow or branch for a project.
         */
        trends: {
            /**
             * The trend value for total credits consumed.
             */
            total_credits_used: number;
            /**
             * The 95th percentile duration among a group of workflow runs.
             */
            p95_duration_secs: number;
            /**
             * The trend value for total number of runs.
             */
            total_runs: number;
            /**
             * The trend value for the success rate.
             */
            success_rate: number;
        };
    }>;
    /**
     * A list of metrics and trends data for branches for a given project.
     */
    project_workflow_branch_data?: Array<{
        /**
         * The name of the workflow.
         */
        workflow_name: string;
        /**
         * The VCS branch of a workflow's trigger.
         */
        branch: string;
        /**
         * Metrics aggregated across a workflow or branchfor a project.
         */
        metrics: {
            /**
             * The total credits consumed over the current timeseries interval.
             */
            total_credits_used: number;
            /**
             * The 95th percentile duration among a group of workflow runs.
             */
            p95_duration_secs: number;
            /**
             * The total number of runs, including runs that are still on-hold or running.
             */
            total_runs: number;
            success_rate: number;
        };
        /**
         * Trends aggregated across a workflow or branch for a project.
         */
        trends: {
            /**
             * The trend value for total credits consumed.
             */
            total_credits_used: number;
            /**
             * The 95th percentile duration among a group of workflow runs.
             */
            p95_duration_secs: number;
            /**
             * The trend value for total number of runs.
             */
            total_runs: number;
            /**
             * The trend value for the success rate.
             */
            success_rate: number;
        };
    }>;
    /**
     * A list of all the branches for a given project.
     */
    all_branches?: Array<(string)>;
    /**
     * A list of all the workflows for a given project.
     */
    all_workflows?: Array<(string)>;
};

export type GetProjectWorkflowsPageDataError = {
    message?: string;
};

export type GetJobTimeseriesData = {
    path: {
        /**
         * Project slug in the form `vcs-slug/org-name/repo-name`. The `/` characters may be URL-escaped. For projects that use GitLab or GitHub App, use `circleci` as the `vcs-slug`, replace `org-name` with the organization ID (found in Organization Settings), and replace `repo-name` with the project ID (found in Project Settings).
         */
        'project-slug': string;
        /**
         * The name of the workflow.
         */
        'workflow-name': string;
    };
    query?: {
        /**
         * The name of a vcs branch. If not passed we will scope the API call to the default branch.
         */
        branch?: string;
        /**
         * Include only executions that started before this date. This date can be at most 90 days after the start-date.
         */
        'end-date'?: string;
        /**
         * The granularity for which to query timeseries data.
         */
        granularity?: 'daily' | 'hourly';
        /**
         * Include only executions that started at or after this date. This must be specified if an end-date is provided.
         */
        'start-date'?: string;
    };
};

export type GetJobTimeseriesResponse = {
    /**
     * A token to pass as a `page-token` query parameter to return the next page of results.
     */
    next_page_token: string;
    /**
     * Aggregate metrics for a workflow at a time granularity
     */
    items: Array<{
        /**
         * The name of the workflow.
         */
        name: string;
        /**
         * The start time for the earliest execution included in the metrics.
         */
        min_started_at: string;
        /**
         * The end time of the last execution included in the metrics.
         */
        max_ended_at: string;
        /**
         * The start of the interval for timeseries metrics.
         */
        timestamp: string;
        /**
         * Metrics relating to a workflow's runs.
         */
        metrics: {
            /**
             * The total number of runs, including runs that are still on-hold or running.
             */
            total_runs: number;
            /**
             * The number of failed runs.
             */
            failed_runs: number;
            /**
             * The number of successful runs.
             */
            successful_runs: number;
            /**
             * The average number of runs per day.
             */
            throughput: number;
            /**
             * The median credits consumed over the current timeseries interval.
             */
            median_credits_used: number;
            /**
             * The total credits consumed over the current timeseries interval.
             */
            total_credits_used: number;
            /**
             * Metrics relating to the duration of runs for a workflow.
             */
            duration_metrics: {
                /**
                 * The minimum duration, in seconds, among a group of runs.
                 */
                min: number;
                /**
                 * The median duration, in seconds, among a group of runs.
                 */
                median: number;
                /**
                 * The max duration, in seconds, among a group of runs.
                 */
                max: number;
                /**
                 * The 95th percentile duration, in seconds, among a group of runs.
                 */
                p95: number;
                /**
                 * The total duration, in seconds, added across a group of runs.
                 */
                total: number;
            };
        };
    }>;
};

export type GetJobTimeseriesError = {
    message?: string;
};

export type GetOrgSummaryDataData = {
    path: {
        /**
         * Org slug in the form `vcs-slug/org-name`. The `/` characters may be URL-escaped.
         */
        'org-slug': string;
    };
    query?: {
        /**
         * List of project names.
         */
        'project-names'?: {
            [key: string]: unknown;
        };
        /**
         * The time window used to calculate summary metrics. If not provided, defaults to last-90-days
         */
        'reporting-window'?: 'last-7-days' | 'last-90-days' | 'last-24-hours' | 'last-30-days' | 'last-60-days';
    };
};

export type GetOrgSummaryDataResponse = {
    /**
     * Aggregated metrics for an org, with trends.
     */
    org_data: {
        /**
         * Metrics for a single org metrics.
         */
        metrics: {
            /**
             * The total number of runs, including runs that are still on-hold or running.
             */
            total_runs: number;
            /**
             * Total duration, in seconds.
             */
            total_duration_secs: number;
            /**
             * The total credits consumed over the current timeseries interval.
             */
            total_credits_used: number;
            success_rate: number;
            /**
             * The average number of runs per day.
             */
            throughput: number;
        };
        /**
         * Trends for a single org.
         */
        trends: {
            /**
             * The trend value for total number of runs.
             */
            total_runs: number;
            /**
             * Trend value for total duration.
             */
            total_duration_secs: number;
            /**
             * The trend value for total credits consumed.
             */
            total_credits_used: number;
            /**
             * The trend value for the success rate.
             */
            success_rate: number;
            /**
             * Trend value for the average number of runs per day.
             */
            throughput: number;
        };
    };
    /**
     * Metrics for a single project, across all branches
     */
    org_project_data: Array<{
        /**
         * The name of the project.
         */
        project_name: string;
        /**
         * Metrics for a single project, across all branches.
         */
        metrics: {
            /**
             * The total credits consumed over the current timeseries interval.
             */
            total_credits_used: number;
            /**
             * Total duration, in seconds.
             */
            total_duration_secs: number;
            /**
             * The total number of runs, including runs that are still on-hold or running.
             */
            total_runs: number;
            success_rate: number;
        };
        /**
         * Trends for a single project, across all branches.
         */
        trends: {
            /**
             * The trend value for total credits consumed.
             */
            total_credits_used: number;
            /**
             * Trend value for total duration.
             */
            total_duration_secs: number;
            /**
             * The trend value for total number of runs.
             */
            total_runs: number;
            /**
             * The trend value for the success rate.
             */
            success_rate: number;
        };
    }>;
    /**
     * A list of all the project names in the organization.
     */
    all_projects: Array<(string)>;
};

export type GetOrgSummaryDataError = {
    message?: string;
};

export type GetAllInsightsBranchesData = {
    path: {
        /**
         * Project slug in the form `vcs-slug/org-name/repo-name`. The `/` characters may be URL-escaped. For projects that use GitLab or GitHub App, use `circleci` as the `vcs-slug`, replace `org-name` with the organization ID (found in Organization Settings), and replace `repo-name` with the project ID (found in Project Settings).
         */
        'project-slug': string;
    };
    query?: {
        /**
         * The name of a workflow. If not passed we will scope the API call to the project.
         */
        'workflow-name'?: string;
    };
};

export type GetAllInsightsBranchesResponse = {
    /**
     * The unique ID of the organization
     */
    org_id: unknown;
    /**
     * The unique ID of the project
     */
    project_id: unknown;
    /**
     * A list of all the branches for a given project.
     */
    branches: Array<(string)>;
};

export type GetAllInsightsBranchesError = {
    message?: string;
};

export type GetFlakyTestsData = {
    path: {
        /**
         * Project slug in the form `vcs-slug/org-name/repo-name`. The `/` characters may be URL-escaped. For projects that use GitLab or GitHub App, use `circleci` as the `vcs-slug`, replace `org-name` with the organization ID (found in Organization Settings), and replace `repo-name` with the project ID (found in Project Settings).
         */
        'project-slug': string;
    };
};

export type GetFlakyTestsResponse = {
    /**
     * A list of all instances of flakes. Note that a test is no longer considered flaky after 2 weeks have passed without a flake. Each flake resets this timer.
     */
    'flaky-tests': Array<{
        'time-wasted'?: number;
        /**
         * The date and time when workflow was created.
         */
        'workflow-created-at': string;
        /**
         * The ID of the workflow associated with the provided test counts
         */
        'workflow-id': unknown;
        /**
         * The class the test belongs to.
         */
        classname: string;
        /**
         * The number of the pipeline.
         */
        'pipeline-number': number;
        /**
         * The name of the workflow.
         */
        'workflow-name': string;
        /**
         * The name of the test.
         */
        'test-name': string;
        /**
         * The name of the job.
         */
        'job-name': string;
        /**
         * The number of the job.
         */
        'job-number': number;
        /**
         * The number of times the test flaked.
         */
        'times-flaked': number;
        /**
         * The source of the test.
         */
        source: string;
        /**
         * The file the test belongs to.
         */
        file: string;
    }>;
    /**
     * A count of unique tests that have failed. If your project has N tests that have flaked multiple times each, this will be equal to N.
     */
    'total-flaky-tests': number;
};

export type GetFlakyTestsError = {
    message?: string;
};

export type GetProjectWorkflowMetricsData = {
    path: {
        /**
         * Project slug in the form `vcs-slug/org-name/repo-name`. The `/` characters may be URL-escaped. For projects that use GitLab or GitHub App, use `circleci` as the `vcs-slug`, replace `org-name` with the organization ID (found in Organization Settings), and replace `repo-name` with the project ID (found in Project Settings).
         */
        'project-slug': string;
    };
    query?: {
        /**
         * Whether to retrieve data for all branches combined. Use either this parameter OR the branch name parameter.
         */
        'all-branches'?: boolean;
        /**
         * The name of a vcs branch. If not passed we will scope the API call to the default branch.
         */
        branch?: string;
        /**
         * A token to retrieve the next page of results.
         */
        'page-token'?: string;
        /**
         * The time window used to calculate summary metrics. If not provided, defaults to last-90-days
         */
        'reporting-window'?: 'last-7-days' | 'last-90-days' | 'last-24-hours' | 'last-30-days' | 'last-60-days';
    };
};

export type GetProjectWorkflowMetricsResponse = {
    /**
     * Workflow summary metrics.
     */
    items: Array<{
        /**
         * The name of the workflow.
         */
        name: string;
        /**
         * Metrics relating to a workflow's runs.
         */
        metrics: {
            /**
             * The total number of runs, including runs that are still on-hold or running.
             */
            total_runs: number;
            /**
             * The number of successful runs.
             */
            successful_runs: number;
            /**
             * The mean time to recovery (mean time between failures and their next success) in seconds.
             */
            mttr: number;
            /**
             * The total credits consumed by the workflow in the aggregation window. Note that Insights is not a real time financial reporting tool and should not be used for credit reporting.
             */
            total_credits_used: number;
            /**
             * The number of failed runs.
             */
            failed_runs: number;
            success_rate: number;
            /**
             * Metrics relating to the duration of runs for a workflow.
             */
            duration_metrics: {
                /**
                 * The minimum duration, in seconds, among a group of runs.
                 */
                min: number;
                /**
                 * The mean duration, in seconds, among a group of runs.
                 */
                mean: number;
                /**
                 * The median duration, in seconds, among a group of runs.
                 */
                median: number;
                /**
                 * The 95th percentile duration, in seconds, among a group of runs.
                 */
                p95: number;
                /**
                 * The max duration, in seconds, among a group of runs.
                 */
                max: number;
                /**
                 * The standard deviation, in seconds, among a group of runs.
                 */
                standard_deviation: number;
            };
            /**
             * The number of recovered workflow executions per day.
             */
            total_recoveries: number;
            /**
             * The average number of runs per day.
             */
            throughput: number;
        };
        /**
         * The timestamp of the first build within the requested reporting window.
         */
        window_start: string;
        /**
         * The timestamp of the last build within the requested reporting window.
         */
        window_end: string;
        /**
         * The unique ID of the project
         */
        project_id: unknown;
    }>;
    /**
     * A token to pass as a `page-token` query parameter to return the next page of results.
     */
    next_page_token: string;
};

export type GetProjectWorkflowMetricsError = {
    message?: string;
};

export type GetProjectWorkflowRunsData = {
    path: {
        /**
         * Project slug in the form `vcs-slug/org-name/repo-name`. The `/` characters may be URL-escaped. For projects that use GitLab or GitHub App, use `circleci` as the `vcs-slug`, replace `org-name` with the organization ID (found in Organization Settings), and replace `repo-name` with the project ID (found in Project Settings).
         */
        'project-slug': string;
        /**
         * The name of the workflow.
         */
        'workflow-name': string;
    };
    query?: {
        /**
         * Whether to retrieve data for all branches combined. Use either this parameter OR the branch name parameter.
         */
        'all-branches'?: boolean;
        /**
         * The name of a vcs branch. If not passed we will scope the API call to the default branch.
         */
        branch?: string;
        /**
         * Include only executions that started before this date. This date can be at most 90 days after the start-date.
         */
        'end-date'?: string;
        /**
         * A token to retrieve the next page of results.
         */
        'page-token'?: string;
        /**
         * Include only executions that started at or after this date. This must be specified if an end-date is provided.
         */
        'start-date'?: string;
    };
};

export type GetProjectWorkflowRunsResponse = {
    /**
     * Recent workflow runs.
     */
    items: Array<{
        /**
         * The unique ID of the workflow.
         */
        id: string;
        /**
         * The VCS branch of a Workflow's trigger.
         */
        branch: string;
        /**
         * The duration in seconds of a run.
         */
        duration: number;
        /**
         * The date and time the workflow was created.
         */
        created_at: string;
        /**
         * The date and time the workflow stopped.
         */
        stopped_at: string;
        /**
         * The number of credits used during execution. Note that Insights is not a real time financial reporting tool and should not be used for credit reporting.
         */
        credits_used: number;
        /**
         * Workflow status.
         */
        status: 'success' | 'failed' | 'error' | 'canceled' | 'unauthorized';
        /**
         * Describes if the job is an approval job or not. Approval jobs are intermediary jobs that are created to pause the workflow until approved.
         */
        is_approval: boolean;
    }>;
    /**
     * A token to pass as a `page-token` query parameter to return the next page of results.
     */
    next_page_token: string;
};

export type GetProjectWorkflowRunsError = {
    message?: string;
};

export type GetProjectWorkflowJobMetricsData = {
    path: {
        /**
         * Project slug in the form `vcs-slug/org-name/repo-name`. The `/` characters may be URL-escaped. For projects that use GitLab or GitHub App, use `circleci` as the `vcs-slug`, replace `org-name` with the organization ID (found in Organization Settings), and replace `repo-name` with the project ID (found in Project Settings).
         */
        'project-slug': string;
        /**
         * The name of the workflow.
         */
        'workflow-name': string;
    };
    query?: {
        /**
         * Whether to retrieve data for all branches combined. Use either this parameter OR the branch name parameter.
         */
        'all-branches'?: boolean;
        /**
         * The name of a vcs branch. If not passed we will scope the API call to the default branch.
         */
        branch?: string;
        /**
         * A token to retrieve the next page of results.
         */
        'page-token'?: string;
        /**
         * The time window used to calculate summary metrics. If not provided, defaults to last-90-days
         */
        'reporting-window'?: 'last-7-days' | 'last-90-days' | 'last-24-hours' | 'last-30-days' | 'last-60-days';
    };
};

export type GetProjectWorkflowJobMetricsResponse = {
    /**
     * Job summary metrics.
     */
    items: Array<{
        /**
         * The name of the job.
         */
        name: string;
        /**
         * Metrics relating to a workflow job's runs.
         */
        metrics: {
            /**
             * The total number of runs, including runs that are still on-hold or running.
             */
            total_runs: number;
            /**
             * The number of failed runs.
             */
            failed_runs: number;
            /**
             * The number of successful runs.
             */
            successful_runs: number;
            /**
             * Metrics relating to the duration of runs for a workflow job.
             */
            duration_metrics: {
                /**
                 * The minimum duration, in seconds, among a group of runs.
                 */
                min: number;
                /**
                 * The mean duration, in seconds, among a group of runs.
                 */
                mean: number;
                /**
                 * The median duration, in seconds, among a group of runs.
                 */
                median: number;
                /**
                 * The 95th percentile duration, in seconds, among a group of runs.
                 */
                p95: number;
                /**
                 * The max duration, in seconds, among a group of runs.
                 */
                max: number;
                /**
                 * The standard deviation, in seconds, among a group of runs.
                 */
                standard_deviation: number;
            };
            success_rate: number;
            /**
             * The total credits consumed by the job in the aggregation window. Note that Insights is not a real time financial reporting tool and should not be used for credit reporting.
             */
            total_credits_used: number;
            /**
             * The average number of runs per day.
             */
            throughput: number;
        };
        /**
         * The timestamp of the first build within the requested reporting window.
         */
        window_start: string;
        /**
         * The timestamp of the last build within the requested reporting window.
         */
        window_end: string;
    }>;
    /**
     * A token to pass as a `page-token` query parameter to return the next page of results.
     */
    next_page_token: string;
};

export type GetProjectWorkflowJobMetricsError = {
    message?: string;
};

export type GetWorkflowSummaryData = {
    path: {
        /**
         * Project slug in the form `vcs-slug/org-name/repo-name`. The `/` characters may be URL-escaped. For projects that use GitLab or GitHub App, use `circleci` as the `vcs-slug`, replace `org-name` with the organization ID (found in Organization Settings), and replace `repo-name` with the project ID (found in Project Settings).
         */
        'project-slug': string;
        /**
         * The name of the workflow.
         */
        'workflow-name': string;
    };
    query?: {
        /**
         * Whether to retrieve data for all branches combined. Use either this parameter OR the branch name parameter.
         */
        'all-branches'?: boolean;
        /**
         * The name of a vcs branch. If not passed we will scope the API call to the default branch.
         */
        branch?: string;
    };
};

export type GetWorkflowSummaryResponse = {
    /**
     * Metrics aggregated across a workflow for a given time window.
     */
    metrics: {
        /**
         * The total number of runs, including runs that are still on-hold or running.
         */
        total_runs: number;
        /**
         * The number of successful runs.
         */
        successful_runs: number;
        /**
         * The mean time to recovery (mean time between failures and their next success) in seconds.
         */
        mttr: number;
        /**
         * The total credits consumed by the workflow in the aggregation window. Note that Insights is not a real time financial reporting tool and should not be used for credit reporting.
         */
        total_credits_used: number;
        /**
         * The number of failed runs.
         */
        failed_runs: number;
        success_rate: number;
        /**
         * The number of runs that ran to completion within the aggregation window
         */
        completed_runs: number;
        /**
         * The timestamp of the first build within the requested reporting window.
         */
        window_start: string;
        /**
         * Metrics relating to the duration of runs for a workflow.
         */
        duration_metrics: {
            /**
             * The minimum duration, in seconds, among a group of runs.
             */
            min: number;
            /**
             * The mean duration, in seconds, among a group of runs.
             */
            mean: number;
            /**
             * The median duration, in seconds, among a group of runs.
             */
            median: number;
            /**
             * The 95th percentile duration, in seconds, among a group of runs.
             */
            p95: number;
            /**
             * The max duration, in seconds, among a group of runs.
             */
            max: number;
            /**
             * The standard deviation, in seconds, among a group of runs.
             */
            standard_deviation: number;
        };
        /**
         * The timestamp of the last build within the requested reporting window.
         */
        window_end: string;
        /**
         * The average number of runs per day.
         */
        throughput: number;
    };
    /**
     * Trends for aggregated metrics across a workflow for a given time window.
     */
    trends: {
        /**
         * The trend value for total number of runs.
         */
        total_runs: number;
        /**
         * The trend value for number of failed runs.
         */
        failed_runs: number;
        /**
         * The trend value for the success rate.
         */
        success_rate: number;
        /**
         * Trend value for the 95th percentile duration for a workflow for a given time window.
         */
        p95_duration_secs: number;
        /**
         * Trend value for the 50th percentile duration for a workflow for a given time window.
         */
        median_duration_secs: number;
        /**
         * The trend value for total credits consumed.
         */
        total_credits_used: number;
        /**
         * trend for mean time to recovery (mean time between failures and their next success).
         */
        mttr: number;
        /**
         * Trend value for the average number of runs per day.
         */
        throughput: number;
    };
    /**
     * A list of all the workflow names for a given project.
     */
    workflow_names: Array<(string)>;
};

export type GetWorkflowSummaryError = {
    message?: string;
};

export type GetProjectWorkflowTestMetricsData = {
    path: {
        /**
         * Project slug in the form `vcs-slug/org-name/repo-name`. The `/` characters may be URL-escaped. For projects that use GitLab or GitHub App, use `circleci` as the `vcs-slug`, replace `org-name` with the organization ID (found in Organization Settings), and replace `repo-name` with the project ID (found in Project Settings).
         */
        'project-slug': string;
        /**
         * The name of the workflow.
         */
        'workflow-name': string;
    };
    query?: {
        /**
         * Whether to retrieve data for all branches combined. Use either this parameter OR the branch name parameter.
         */
        'all-branches'?: boolean;
        /**
         * The name of a vcs branch. If not passed we will scope the API call to the default branch.
         */
        branch?: string;
    };
};

export type GetProjectWorkflowTestMetricsResponse = {
    /**
     * The average number of tests executed per run
     */
    average_test_count: number;
    /**
     * Metrics for the most frequently failing tests
     */
    most_failed_tests: Array<{
        /**
         * The 95th percentile duration, in seconds, among a group of test runs.
         */
        p95_duration: number;
        /**
         * The total number of times the test was run.
         */
        total_runs: number;
        /**
         * The class the test belongs to.
         */
        classname: string;
        /**
         * The number of times the test failed
         */
        failed_runs: number;
        /**
         * Whether the test is flaky.
         */
        flaky: boolean;
        /**
         * The source of the test.
         */
        source: string;
        /**
         * The file the test belongs to.
         */
        file: string;
        /**
         * The name of the job.
         */
        job_name: string;
        /**
         * The name of the test.
         */
        test_name: string;
    }>;
    /**
     * The number of tests with the same success rate being omitted from most_failed_tests
     */
    most_failed_tests_extra: number;
    /**
     * Metrics for the slowest running tests
     */
    slowest_tests: Array<{
        /**
         * The 95th percentile duration, in seconds, among a group of test runs.
         */
        p95_duration: number;
        /**
         * The total number of times the test was run.
         */
        total_runs: number;
        /**
         * The class the test belongs to.
         */
        classname: string;
        /**
         * The number of times the test failed
         */
        failed_runs: number;
        /**
         * Whether the test is flaky.
         */
        flaky: boolean;
        /**
         * The source of the test.
         */
        source: string;
        /**
         * The file the test belongs to.
         */
        file: string;
        /**
         * The name of the job.
         */
        job_name: string;
        /**
         * The name of the test.
         */
        test_name: string;
    }>;
    /**
     * The number of tests with the same duration rate being omitted from slowest_tests
     */
    slowest_tests_extra: number;
    /**
     * The total number of test runs
     */
    total_test_runs: number;
    /**
     * Test counts grouped by pipeline number and workflow id
     */
    test_runs: Array<{
        /**
         * The number of the pipeline associated with the provided test counts
         */
        pipeline_number: number;
        /**
         * The ID of the workflow associated with the provided test counts
         */
        workflow_id: unknown;
        /**
         * The success rate calculated from test counts
         */
        success_rate: number;
        /**
         * Test counts for a given pipeline number
         */
        test_counts: {
            /**
             * The number of tests with the error status
             */
            error: number;
            /**
             * The number of tests with the failure status
             */
            failure: number;
            /**
             * The number of tests with the skipped status
             */
            skipped: number;
            /**
             * The number of tests with the success status
             */
            success: number;
            /**
             * The total number of tests
             */
            total: number;
        };
    }>;
};

export type GetProjectWorkflowTestMetricsError = {
    message?: string;
};

export type GetCurrentUserResponse = {
    /**
     * The unique ID of the user.
     */
    id: string;
    /**
     * The login information for the user on the VCS.
     */
    login: string;
    /**
     * The name of the user.
     */
    name: string;
};

export type GetCurrentUserError = {
    message?: string;
};

export type GetCollaborationsResponse = Array<{
    /**
     * The UUID of the organization
     */
    id: string;
    /**
     * The VCS provider
     */
    'vcs-type': string;
    /**
     * The name of the organization
     */
    name: string;
    /**
     * URL to the user's avatar on the VCS
     */
    avatar_url: string;
    /**
     * The slug of the organization
     */
    slug: string;
}>;

export type GetCollaborationsError = {
    message?: string;
};

export type ListPipelinesData = {
    query?: {
        /**
         * Only include entries created by your user.
         */
        mine?: boolean;
        /**
         * Org slug in the form `vcs-slug/org-name`. For projects that use GitLab or GitHub App, use `circleci` as the `vcs-slug` and replace the `org-name` with the organization ID (found in Organization Settings).
         */
        'org-slug'?: string;
        /**
         * A token to retrieve the next page of results.
         */
        'page-token'?: string;
    };
};

export type ListPipelinesResponse = {
    items: Array<{
        /**
         * The unique ID of the pipeline.
         */
        id: string;
        /**
         * A sequence of errors that have occurred within the pipeline.
         */
        errors: Array<{
            /**
             * The type of error.
             */
            type: 'config' | 'config-fetch' | 'timeout' | 'permission' | 'other' | 'trigger-rule' | 'plan';
            /**
             * A human-readable error message.
             */
            message: string;
        }>;
        /**
         * The project-slug for the pipeline.
         */
        project_slug: string;
        /**
         * The date and time the pipeline was last updated.
         */
        updated_at?: string;
        /**
         * The number of the pipeline.
         */
        number: number;
        trigger_parameters?: {
            [key: string]: (string | number | boolean | {
    [key: string]: unknown;
});
        };
        /**
         * The current state of the pipeline.
         */
        state: 'created' | 'errored' | 'setup-pending' | 'setup' | 'pending';
        /**
         * The date and time the pipeline was created.
         */
        created_at: string;
        /**
         * A summary of the trigger.
         */
        trigger: {
            /**
             * The type of trigger.
             */
            type: 'scheduled_pipeline' | 'explicit' | 'api' | 'webhook';
            /**
             * The date and time the trigger was received.
             */
            received_at: string;
            /**
             * The user who triggered the Pipeline.
             */
            actor: {
                /**
                 * The login information for the user on the VCS.
                 */
                login: string;
                /**
                 * URL to the user's avatar on the VCS
                 */
                avatar_url: string;
            };
        };
        /**
         * VCS information for the pipeline.
         */
        vcs?: {
            /**
             * Name of the VCS provider (e.g. GitHub, Bitbucket).
             */
            provider_name: string;
            /**
             * URL for the repository the trigger targets (i.e. the repository where the PR will be merged). For fork-PR pipelines, this is the URL to the parent repo. For other pipelines, the `origin_` and `target_repository_url`s will be the same.
             */
            target_repository_url: string;
            /**
             * The branch where the pipeline ran. The HEAD commit on this branch was used for the pipeline. Note that `branch` and `tag` are mutually exclusive. To trigger a pipeline for a PR by number use `pull/<number>/head` for the PR ref or `pull/<number>/merge` for the merge ref (GitHub only).
             */
            branch?: string;
            /**
             * The code review id.
             */
            review_id?: string;
            /**
             * The code review URL.
             */
            review_url?: string;
            /**
             * The code revision the pipeline ran.
             */
            revision: string;
            /**
             * The tag used by the pipeline. The commit that this tag points to was used for the pipeline. Note that `branch` and `tag` are mutually exclusive.
             */
            tag?: string;
            /**
             * The latest commit in the pipeline.
             */
            commit?: {
                /**
                 * The subject of the commit message.
                 */
                subject: string;
                /**
                 * The body of the commit message.
                 */
                body: string;
            };
            /**
             * URL for the repository where the trigger originated. For fork-PR pipelines, this is the URL to the fork. For other pipelines the `origin_` and `target_repository_url`s will be the same.
             */
            origin_repository_url: string;
        };
    }>;
    /**
     * A token to pass as a `page-token` query parameter to return the next page of results.
     */
    next_page_token: string;
};

export type ListPipelinesError = {
    message?: string;
};

export type ContinuePipelineData = {
    body?: {
        /**
         * A pipeline continuation key.
         */
        'continuation-key': string;
        /**
         * A configuration string for the pipeline.
         */
        configuration: string;
        /**
         * An object containing pipeline parameters and their values. Pipeline parameters have the following size limits: 100 max entries, 128 maximum key length, 512 maximum value length.
         */
        parameters?: {
            [key: string]: (number | string | boolean);
        };
    };
};

export type ContinuePipelineResponse = {
    /**
     * A human-readable message
     */
    message: string;
};

export type ContinuePipelineError = {
    message?: string;
};

export type GetPipelineByIdData = {
    path: {
        /**
         * The unique ID of the pipeline.
         */
        'pipeline-id': string;
    };
};

export type GetPipelineByIdResponse = {
    /**
     * The unique ID of the pipeline.
     */
    id: string;
    /**
     * A sequence of errors that have occurred within the pipeline.
     */
    errors: Array<{
        /**
         * The type of error.
         */
        type: 'config' | 'config-fetch' | 'timeout' | 'permission' | 'other' | 'trigger-rule' | 'plan';
        /**
         * A human-readable error message.
         */
        message: string;
    }>;
    /**
     * The project-slug for the pipeline.
     */
    project_slug: string;
    /**
     * The date and time the pipeline was last updated.
     */
    updated_at?: string;
    /**
     * The number of the pipeline.
     */
    number: number;
    trigger_parameters?: {
        [key: string]: (string | number | boolean | {
    [key: string]: unknown;
});
    };
    /**
     * The current state of the pipeline.
     */
    state: 'created' | 'errored' | 'setup-pending' | 'setup' | 'pending';
    /**
     * The date and time the pipeline was created.
     */
    created_at: string;
    /**
     * A summary of the trigger.
     */
    trigger: {
        /**
         * The type of trigger.
         */
        type: 'scheduled_pipeline' | 'explicit' | 'api' | 'webhook';
        /**
         * The date and time the trigger was received.
         */
        received_at: string;
        /**
         * The user who triggered the Pipeline.
         */
        actor: {
            /**
             * The login information for the user on the VCS.
             */
            login: string;
            /**
             * URL to the user's avatar on the VCS
             */
            avatar_url: string;
        };
    };
    /**
     * VCS information for the pipeline.
     */
    vcs?: {
        /**
         * Name of the VCS provider (e.g. GitHub, Bitbucket).
         */
        provider_name: string;
        /**
         * URL for the repository the trigger targets (i.e. the repository where the PR will be merged). For fork-PR pipelines, this is the URL to the parent repo. For other pipelines, the `origin_` and `target_repository_url`s will be the same.
         */
        target_repository_url: string;
        /**
         * The branch where the pipeline ran. The HEAD commit on this branch was used for the pipeline. Note that `branch` and `tag` are mutually exclusive. To trigger a pipeline for a PR by number use `pull/<number>/head` for the PR ref or `pull/<number>/merge` for the merge ref (GitHub only).
         */
        branch?: string;
        /**
         * The code review id.
         */
        review_id?: string;
        /**
         * The code review URL.
         */
        review_url?: string;
        /**
         * The code revision the pipeline ran.
         */
        revision: string;
        /**
         * The tag used by the pipeline. The commit that this tag points to was used for the pipeline. Note that `branch` and `tag` are mutually exclusive.
         */
        tag?: string;
        /**
         * The latest commit in the pipeline.
         */
        commit?: {
            /**
             * The subject of the commit message.
             */
            subject: string;
            /**
             * The body of the commit message.
             */
            body: string;
        };
        /**
         * URL for the repository where the trigger originated. For fork-PR pipelines, this is the URL to the fork. For other pipelines the `origin_` and `target_repository_url`s will be the same.
         */
        origin_repository_url: string;
    };
};

export type GetPipelineByIdError = {
    message?: string;
};

export type GetPipelineConfigByIdData = {
    path: {
        /**
         * The unique ID of the pipeline.
         */
        'pipeline-id': string;
    };
};

export type GetPipelineConfigByIdResponse = {
    /**
     * The source configuration for the pipeline, before any config compilation has been performed. If there is no config, then this field will be empty.
     */
    source: string;
    /**
     * The compiled configuration for the pipeline, after all orb expansion has been performed. If there were errors processing the pipeline's configuration, then this field may be empty.
     */
    compiled: string;
    /**
     * The setup configuration for the pipeline used for Setup Workflows. If there were errors processing the pipeline's configuration or if setup workflows are not enabled, then this field should not exist
     */
    'setup-config'?: string;
    /**
     * The compiled setup configuration for the pipeline, after all orb expansion has been performed. If there were errors processing the pipeline's setup workflows, then this field may be empty.
     */
    'compiled-setup-config'?: string;
};

export type GetPipelineConfigByIdError = {
    message?: string;
};

export type ListWorkflowsByPipelineIdData = {
    path: {
        /**
         * The unique ID of the pipeline.
         */
        'pipeline-id': string;
    };
    query?: {
        /**
         * A token to retrieve the next page of results.
         */
        'page-token'?: string;
    };
};

export type ListWorkflowsByPipelineIdResponse = {
    /**
     * A list of workflows.
     */
    items: Array<{
        /**
         * The ID of the pipeline this workflow belongs to.
         */
        pipeline_id: string;
        canceled_by?: string;
        /**
         * The unique ID of the workflow.
         */
        id: string;
        /**
         * The name of the workflow.
         */
        name: string;
        /**
         * The project-slug for the pipeline this workflow belongs to.
         */
        project_slug: string;
        errored_by?: string;
        /**
         * Tag used for the workflow
         */
        tag?: 'setup';
        /**
         * The current status of the workflow.
         */
        status: 'success' | 'running' | 'not_run' | 'failed' | 'error' | 'failing' | 'on_hold' | 'canceled' | 'unauthorized';
        started_by: string;
        /**
         * The number of the pipeline this workflow belongs to.
         */
        pipeline_number: number;
        /**
         * The date and time the workflow was created.
         */
        created_at: string;
        /**
         * The date and time the workflow stopped.
         */
        stopped_at: string;
    }>;
    /**
     * A token to pass as a `page-token` query parameter to return the next page of results.
     */
    next_page_token: string;
};

export type ListWorkflowsByPipelineIdError = {
    message?: string;
};

export type GetProjectBySlugData = {
    path: {
        /**
         * Project slug in the form `vcs-slug/org-name/repo-name`. The `/` characters may be URL-escaped. For projects that use GitLab or GitHub App, use `circleci` as the `vcs-slug`, replace `org-name` with the organization ID (found in Organization Settings), and replace `repo-name` with the project ID (found in Project Settings).
         */
        'project-slug': string;
    };
};

export type GetProjectBySlugResponse = {
    /**
     * Project slug in the form `vcs-slug/org-name/repo-name`. The `/` characters may be URL-escaped. For projects that use GitLab or GitHub App, use `circleci` as the `vcs-slug`, replace `org-name` with the organization ID (found in Organization Settings), and replace `repo-name` with the project ID (found in Project Settings).
     */
    slug: string;
    /**
     * The name of the project
     */
    name: string;
    id: string;
    /**
     * The name of the organization the project belongs to
     */
    organization_name: string;
    /**
     * The slug of the organization the project belongs to
     */
    organization_slug: string;
    /**
     * The id of the organization the project belongs to
     */
    organization_id: string;
    /**
     * Information about the VCS that hosts the project source code.
     */
    vcs_info: {
        /**
         * URL to the repository hosting the project's code
         */
        vcs_url: string;
        /**
         * The VCS provider
         */
        provider: 'Bitbucket' | 'CircleCI' | 'GitHub';
        default_branch: string;
    };
};

export type GetProjectBySlugError = {
    message?: string;
};

export type CreateCheckoutKeyData = {
    body?: {
        /**
         * The type of checkout key to create. This may be either `deploy-key` or `user-key`.
         */
        type: 'user-key' | 'deploy-key';
    };
    path: {
        /**
         * Project slug in the form `vcs-slug/org-name/repo-name`. The `/` characters may be URL-escaped. For projects that use GitLab or GitHub App, use `circleci` as the `vcs-slug`, replace `org-name` with the organization ID (found in Organization Settings), and replace `repo-name` with the project ID (found in Project Settings).
         */
        'project-slug': string;
    };
};

export type CreateCheckoutKeyResponse = {
    /**
     * A public SSH key.
     */
    'public-key': string;
    /**
     * The type of checkout key. This may be either `deploy-key` or `github-user-key`.
     */
    type: 'deploy-key' | 'github-user-key';
    /**
     * An SSH key fingerprint.
     */
    fingerprint: string;
    /**
     * A boolean value that indicates if this key is preferred.
     */
    preferred: boolean;
    /**
     * The date and time the checkout key was created.
     */
    'created-at': string;
};

export type CreateCheckoutKeyError = {
    message?: string;
};

export type ListCheckoutKeysData = {
    path: {
        /**
         * Project slug in the form `vcs-slug/org-name/repo-name`. The `/` characters may be URL-escaped. For projects that use GitLab or GitHub App, use `circleci` as the `vcs-slug`, replace `org-name` with the organization ID (found in Organization Settings), and replace `repo-name` with the project ID (found in Project Settings).
         */
        'project-slug': string;
    };
    query?: {
        /**
         * The fingerprint digest type to return. This may be either `md5` or `sha256`. If not passed, defaults to `md5`.
         */
        digest?: 'sha256' | 'md5';
    };
};

export type ListCheckoutKeysResponse = {
    items: Array<{
        /**
         * A public SSH key.
         */
        'public-key': string;
        /**
         * The type of checkout key. This may be either `deploy-key` or `github-user-key`.
         */
        type: 'deploy-key' | 'github-user-key';
        /**
         * An SSH key fingerprint.
         */
        fingerprint: string;
        /**
         * A boolean value that indicates if this key is preferred.
         */
        preferred: boolean;
        /**
         * The date and time the checkout key was created.
         */
        'created-at': string;
    }>;
    /**
     * A token to pass as a `page-token` query parameter to return the next page of results.
     */
    next_page_token: string;
};

export type ListCheckoutKeysError = {
    message?: string;
};

export type DeleteCheckoutKeyData = {
    path: {
        /**
         * An SSH key fingerprint.
         */
        fingerprint: string;
        /**
         * Project slug in the form `vcs-slug/org-name/repo-name`. The `/` characters may be URL-escaped. For projects that use GitLab or GitHub App, use `circleci` as the `vcs-slug`, replace `org-name` with the organization ID (found in Organization Settings), and replace `repo-name` with the project ID (found in Project Settings).
         */
        'project-slug': string;
    };
};

export type DeleteCheckoutKeyResponse = {
    /**
     * A human-readable message
     */
    message: string;
};

export type DeleteCheckoutKeyError = {
    message?: string;
};

export type GetCheckoutKeyData = {
    path: {
        /**
         * An SSH key fingerprint.
         */
        fingerprint: string;
        /**
         * Project slug in the form `vcs-slug/org-name/repo-name`. The `/` characters may be URL-escaped. For projects that use GitLab or GitHub App, use `circleci` as the `vcs-slug`, replace `org-name` with the organization ID (found in Organization Settings), and replace `repo-name` with the project ID (found in Project Settings).
         */
        'project-slug': string;
    };
};

export type GetCheckoutKeyResponse = {
    /**
     * A public SSH key.
     */
    'public-key': string;
    /**
     * The type of checkout key. This may be either `deploy-key` or `github-user-key`.
     */
    type: 'deploy-key' | 'github-user-key';
    /**
     * An SSH key fingerprint.
     */
    fingerprint: string;
    /**
     * A boolean value that indicates if this key is preferred.
     */
    preferred: boolean;
    /**
     * The date and time the checkout key was created.
     */
    'created-at': string;
};

export type GetCheckoutKeyError = {
    message?: string;
};

export type ListEnvVarsData = {
    path: {
        /**
         * Project slug in the form `vcs-slug/org-name/repo-name`. The `/` characters may be URL-escaped. For projects that use GitLab or GitHub App, use `circleci` as the `vcs-slug`, replace `org-name` with the organization ID (found in Organization Settings), and replace `repo-name` with the project ID (found in Project Settings).
         */
        'project-slug': string;
    };
};

export type ListEnvVarsResponse = {
    items: Array<{
        /**
         * The name of the environment variable.
         */
        name: string;
        /**
         * The value of the environment variable.
         */
        value: string;
        /**
         * The creation timestamp of the environment variable.
         */
        'created-at'?: unknown;
    }>;
    /**
     * A token to pass as a `page-token` query parameter to return the next page of results.
     */
    next_page_token: string;
};

export type ListEnvVarsError = {
    message?: string;
};

export type CreateEnvVarData = {
    body?: {
        /**
         * The name of the environment variable.
         */
        name: string;
        /**
         * The value of the environment variable.
         */
        value: string;
    };
    path: {
        /**
         * Project slug in the form `vcs-slug/org-name/repo-name`. The `/` characters may be URL-escaped. For projects that use GitLab or GitHub App, use `circleci` as the `vcs-slug`, replace `org-name` with the organization ID (found in Organization Settings), and replace `repo-name` with the project ID (found in Project Settings).
         */
        'project-slug': string;
    };
};

export type CreateEnvVarResponse = {
    /**
     * The name of the environment variable.
     */
    name: string;
    /**
     * The value of the environment variable.
     */
    value: string;
    /**
     * The creation timestamp of the environment variable.
     */
    'created-at'?: unknown;
};

export type CreateEnvVarError = {
    message?: string;
};

export type DeleteEnvVarData = {
    path: {
        /**
         * The name of the environment variable.
         */
        name: string;
        /**
         * Project slug in the form `vcs-slug/org-name/repo-name`. The `/` characters may be URL-escaped. For projects that use GitLab or GitHub App, use `circleci` as the `vcs-slug`, replace `org-name` with the organization ID (found in Organization Settings), and replace `repo-name` with the project ID (found in Project Settings).
         */
        'project-slug': string;
    };
};

export type DeleteEnvVarResponse = {
    /**
     * A human-readable message
     */
    message: string;
};

export type DeleteEnvVarError = {
    message?: string;
};

export type GetEnvVarData = {
    path: {
        /**
         * The name of the environment variable.
         */
        name: string;
        /**
         * Project slug in the form `vcs-slug/org-name/repo-name`. The `/` characters may be URL-escaped. For projects that use GitLab or GitHub App, use `circleci` as the `vcs-slug`, replace `org-name` with the organization ID (found in Organization Settings), and replace `repo-name` with the project ID (found in Project Settings).
         */
        'project-slug': string;
    };
};

export type GetEnvVarResponse = {
    /**
     * The name of the environment variable.
     */
    name: string;
    /**
     * The value of the environment variable.
     */
    value: string;
    /**
     * The creation timestamp of the environment variable.
     */
    'created-at'?: unknown;
};

export type GetEnvVarError = {
    message?: string;
};

export type GetJobDetailsData = {
    path: {
        /**
         * The number of the job.
         */
        'job-number': unknown;
        /**
         * Project slug in the form `vcs-slug/org-name/repo-name`. The `/` characters may be URL-escaped. For projects that use GitLab or GitHub App, use `circleci` as the `vcs-slug`, replace `org-name` with the organization ID (found in Organization Settings), and replace `repo-name` with the project ID (found in Project Settings).
         */
        'project-slug': string;
    };
};

export type GetJobDetailsResponse = {
    /**
     * URL of the job in CircleCI Web UI.
     */
    web_url: string;
    /**
     * Information about a project.
     */
    project: {
        id: string;
        /**
         * Project slug in the form `vcs-slug/org-name/repo-name`. The `/` characters may be URL-escaped. For projects that use GitLab or GitHub App, use `circleci` as the `vcs-slug`, replace `org-name` with the organization ID (found in Organization Settings), and replace `repo-name` with the project ID (found in Project Settings).
         */
        slug: string;
        /**
         * The name of the project
         */
        name: string;
        /**
         * URL to the repository hosting the project's code
         */
        external_url: string;
    };
    /**
     * Info about parallels runs and their status.
     */
    parallel_runs: Array<{
        /**
         * Index of the parallel run.
         */
        index: number;
        /**
         * Status of the parallel run.
         */
        status: string;
    }>;
    /**
     * The date and time the job started.
     */
    started_at: string;
    /**
     * Info about the latest workflow the job was a part of.
     */
    latest_workflow: {
        /**
         * The unique ID of the workflow.
         */
        id: string;
        /**
         * The name of the workflow.
         */
        name: string;
    };
    /**
     * The name of the job.
     */
    name: string;
    /**
     * Information about executor used for a job.
     */
    executor: {
        /**
         * Resource class name.
         */
        resource_class: string;
        /**
         * Executor type.
         */
        type?: string;
    };
    /**
     * A number of parallel runs the job has.
     */
    parallelism: number;
    /**
     * The current status of the job.
     */
    status: 'success' | 'running' | 'not_run' | 'failed' | 'retried' | 'queued' | 'not_running' | 'infrastructure_fail' | 'timedout' | 'on_hold' | 'terminated-unknown' | 'blocked' | 'canceled' | 'unauthorized';
    /**
     * The number of the job.
     */
    number: number;
    /**
     * Info about a pipeline the job is a part of.
     */
    pipeline: {
        /**
         * The unique ID of the pipeline.
         */
        id: string;
    };
    /**
     * Duration of a job in milliseconds.
     */
    duration: number;
    /**
     * The time when the job was created.
     */
    created_at: string;
    /**
     * Messages from CircleCI execution platform.
     */
    messages: Array<{
        /**
         * Message type.
         */
        type: string;
        /**
         * Information describing message.
         */
        message: string;
        /**
         * Value describing the reason for message to be added to the job.
         */
        reason?: string;
    }>;
    /**
     * List of contexts used by the job.
     */
    contexts: Array<{
        /**
         * The name of the context.
         */
        name: string;
    }>;
    /**
     * Information about an organization.
     */
    organization: {
        /**
         * The name of the organization.
         */
        name: string;
    };
    /**
     * The time when the job was placed in a queue.
     */
    queued_at: string;
    /**
     * The time when the job stopped.
     */
    stopped_at?: string;
};

export type GetJobDetailsError = {
    message?: string;
};

export type CancelJobData = {
    path: {
        /**
         * The number of the job.
         */
        'job-number': unknown;
        /**
         * Project slug in the form `vcs-slug/org-name/repo-name`. The `/` characters may be URL-escaped. For projects that use GitLab or GitHub App, use `circleci` as the `vcs-slug`, replace `org-name` with the organization ID (found in Organization Settings), and replace `repo-name` with the project ID (found in Project Settings).
         */
        'project-slug': string;
    };
};

export type CancelJobResponse = {
    /**
     * A human-readable message
     */
    message: string;
};

export type CancelJobError = {
    message?: string;
};

export type ListPipelinesForProjectData = {
    path: {
        /**
         * Project slug in the form `vcs-slug/org-name/repo-name`. The `/` characters may be URL-escaped. For projects that use GitLab or GitHub App, use `circleci` as the `vcs-slug`, replace `org-name` with the organization ID (found in Organization Settings), and replace `repo-name` with the project ID (found in Project Settings).
         */
        'project-slug': string;
    };
    query?: {
        /**
         * The name of a vcs branch.
         */
        branch?: string;
        /**
         * A token to retrieve the next page of results.
         */
        'page-token'?: string;
    };
};

export type ListPipelinesForProjectResponse = {
    items: Array<{
        /**
         * The unique ID of the pipeline.
         */
        id: string;
        /**
         * A sequence of errors that have occurred within the pipeline.
         */
        errors: Array<{
            /**
             * The type of error.
             */
            type: 'config' | 'config-fetch' | 'timeout' | 'permission' | 'other' | 'trigger-rule' | 'plan';
            /**
             * A human-readable error message.
             */
            message: string;
        }>;
        /**
         * The project-slug for the pipeline.
         */
        project_slug: string;
        /**
         * The date and time the pipeline was last updated.
         */
        updated_at?: string;
        /**
         * The number of the pipeline.
         */
        number: number;
        trigger_parameters?: {
            [key: string]: (string | number | boolean | {
    [key: string]: unknown;
});
        };
        /**
         * The current state of the pipeline.
         */
        state: 'created' | 'errored' | 'setup-pending' | 'setup' | 'pending';
        /**
         * The date and time the pipeline was created.
         */
        created_at: string;
        /**
         * A summary of the trigger.
         */
        trigger: {
            /**
             * The type of trigger.
             */
            type: 'scheduled_pipeline' | 'explicit' | 'api' | 'webhook';
            /**
             * The date and time the trigger was received.
             */
            received_at: string;
            /**
             * The user who triggered the Pipeline.
             */
            actor: {
                /**
                 * The login information for the user on the VCS.
                 */
                login: string;
                /**
                 * URL to the user's avatar on the VCS
                 */
                avatar_url: string;
            };
        };
        /**
         * VCS information for the pipeline.
         */
        vcs?: {
            /**
             * Name of the VCS provider (e.g. GitHub, Bitbucket).
             */
            provider_name: string;
            /**
             * URL for the repository the trigger targets (i.e. the repository where the PR will be merged). For fork-PR pipelines, this is the URL to the parent repo. For other pipelines, the `origin_` and `target_repository_url`s will be the same.
             */
            target_repository_url: string;
            /**
             * The branch where the pipeline ran. The HEAD commit on this branch was used for the pipeline. Note that `branch` and `tag` are mutually exclusive. To trigger a pipeline for a PR by number use `pull/<number>/head` for the PR ref or `pull/<number>/merge` for the merge ref (GitHub only).
             */
            branch?: string;
            /**
             * The code review id.
             */
            review_id?: string;
            /**
             * The code review URL.
             */
            review_url?: string;
            /**
             * The code revision the pipeline ran.
             */
            revision: string;
            /**
             * The tag used by the pipeline. The commit that this tag points to was used for the pipeline. Note that `branch` and `tag` are mutually exclusive.
             */
            tag?: string;
            /**
             * The latest commit in the pipeline.
             */
            commit?: {
                /**
                 * The subject of the commit message.
                 */
                subject: string;
                /**
                 * The body of the commit message.
                 */
                body: string;
            };
            /**
             * URL for the repository where the trigger originated. For fork-PR pipelines, this is the URL to the fork. For other pipelines the `origin_` and `target_repository_url`s will be the same.
             */
            origin_repository_url: string;
        };
    }>;
    /**
     * A token to pass as a `page-token` query parameter to return the next page of results.
     */
    next_page_token: string;
};

export type ListPipelinesForProjectError = {
    message?: string;
};

export type TriggerPipelineData = {
    body?: {
        /**
         * The branch where the pipeline ran. The HEAD commit on this branch was used for the pipeline. Note that `branch` and `tag` are mutually exclusive. To trigger a pipeline for a PR by number use `pull/<number>/head` for the PR ref or `pull/<number>/merge` for the merge ref (GitHub only).
         */
        branch?: string;
        /**
         * The tag used by the pipeline. The commit that this tag points to was used for the pipeline. Note that `branch` and `tag` are mutually exclusive.
         */
        tag?: string;
        /**
         * An object containing pipeline parameters and their values. Pipeline parameters have the following size limits: 100 max entries, 128 maximum key length, 512 maximum value length.
         */
        parameters?: {
            [key: string]: (number | string | boolean);
        };
    };
    path: {
        /**
         * Project slug in the form `vcs-slug/org-name/repo-name`. The `/` characters may be URL-escaped. For projects that use GitLab or GitHub App, use `circleci` as the `vcs-slug`, replace `org-name` with the organization ID (found in Organization Settings), and replace `repo-name` with the project ID (found in Project Settings).
         */
        'project-slug': string;
    };
};

export type TriggerPipelineResponse = {
    /**
     * The unique ID of the pipeline.
     */
    id: string;
    /**
     * The current state of the pipeline.
     */
    state: 'created' | 'errored' | 'setup-pending' | 'setup' | 'pending';
    /**
     * The number of the pipeline.
     */
    number: number;
    /**
     * The date and time the pipeline was created.
     */
    created_at: string;
};

export type TriggerPipelineError = {
    message?: string;
};

export type ListMyPipelinesData = {
    path: {
        /**
         * Project slug in the form `vcs-slug/org-name/repo-name`. The `/` characters may be URL-escaped. For projects that use GitLab or GitHub App, use `circleci` as the `vcs-slug`, replace `org-name` with the organization ID (found in Organization Settings), and replace `repo-name` with the project ID (found in Project Settings).
         */
        'project-slug': string;
    };
    query?: {
        /**
         * A token to retrieve the next page of results.
         */
        'page-token'?: string;
    };
};

export type ListMyPipelinesResponse = {
    items: Array<{
        /**
         * The unique ID of the pipeline.
         */
        id: string;
        /**
         * A sequence of errors that have occurred within the pipeline.
         */
        errors: Array<{
            /**
             * The type of error.
             */
            type: 'config' | 'config-fetch' | 'timeout' | 'permission' | 'other' | 'trigger-rule' | 'plan';
            /**
             * A human-readable error message.
             */
            message: string;
        }>;
        /**
         * The project-slug for the pipeline.
         */
        project_slug: string;
        /**
         * The date and time the pipeline was last updated.
         */
        updated_at?: string;
        /**
         * The number of the pipeline.
         */
        number: number;
        trigger_parameters?: {
            [key: string]: (string | number | boolean | {
    [key: string]: unknown;
});
        };
        /**
         * The current state of the pipeline.
         */
        state: 'created' | 'errored' | 'setup-pending' | 'setup' | 'pending';
        /**
         * The date and time the pipeline was created.
         */
        created_at: string;
        /**
         * A summary of the trigger.
         */
        trigger: {
            /**
             * The type of trigger.
             */
            type: 'scheduled_pipeline' | 'explicit' | 'api' | 'webhook';
            /**
             * The date and time the trigger was received.
             */
            received_at: string;
            /**
             * The user who triggered the Pipeline.
             */
            actor: {
                /**
                 * The login information for the user on the VCS.
                 */
                login: string;
                /**
                 * URL to the user's avatar on the VCS
                 */
                avatar_url: string;
            };
        };
        /**
         * VCS information for the pipeline.
         */
        vcs?: {
            /**
             * Name of the VCS provider (e.g. GitHub, Bitbucket).
             */
            provider_name: string;
            /**
             * URL for the repository the trigger targets (i.e. the repository where the PR will be merged). For fork-PR pipelines, this is the URL to the parent repo. For other pipelines, the `origin_` and `target_repository_url`s will be the same.
             */
            target_repository_url: string;
            /**
             * The branch where the pipeline ran. The HEAD commit on this branch was used for the pipeline. Note that `branch` and `tag` are mutually exclusive. To trigger a pipeline for a PR by number use `pull/<number>/head` for the PR ref or `pull/<number>/merge` for the merge ref (GitHub only).
             */
            branch?: string;
            /**
             * The code review id.
             */
            review_id?: string;
            /**
             * The code review URL.
             */
            review_url?: string;
            /**
             * The code revision the pipeline ran.
             */
            revision: string;
            /**
             * The tag used by the pipeline. The commit that this tag points to was used for the pipeline. Note that `branch` and `tag` are mutually exclusive.
             */
            tag?: string;
            /**
             * The latest commit in the pipeline.
             */
            commit?: {
                /**
                 * The subject of the commit message.
                 */
                subject: string;
                /**
                 * The body of the commit message.
                 */
                body: string;
            };
            /**
             * URL for the repository where the trigger originated. For fork-PR pipelines, this is the URL to the fork. For other pipelines the `origin_` and `target_repository_url`s will be the same.
             */
            origin_repository_url: string;
        };
    }>;
    /**
     * A token to pass as a `page-token` query parameter to return the next page of results.
     */
    next_page_token: string;
};

export type ListMyPipelinesError = {
    message?: string;
};

export type GetPipelineByNumberData = {
    path: {
        /**
         * The number of the pipeline.
         */
        'pipeline-number': unknown;
        /**
         * Project slug in the form `vcs-slug/org-name/repo-name`. The `/` characters may be URL-escaped. For projects that use GitLab or GitHub App, use `circleci` as the `vcs-slug`, replace `org-name` with the organization ID (found in Organization Settings), and replace `repo-name` with the project ID (found in Project Settings).
         */
        'project-slug': string;
    };
};

export type GetPipelineByNumberResponse = {
    /**
     * The unique ID of the pipeline.
     */
    id: string;
    /**
     * A sequence of errors that have occurred within the pipeline.
     */
    errors: Array<{
        /**
         * The type of error.
         */
        type: 'config' | 'config-fetch' | 'timeout' | 'permission' | 'other' | 'trigger-rule' | 'plan';
        /**
         * A human-readable error message.
         */
        message: string;
    }>;
    /**
     * The project-slug for the pipeline.
     */
    project_slug: string;
    /**
     * The date and time the pipeline was last updated.
     */
    updated_at?: string;
    /**
     * The number of the pipeline.
     */
    number: number;
    trigger_parameters?: {
        [key: string]: (string | number | boolean | {
    [key: string]: unknown;
});
    };
    /**
     * The current state of the pipeline.
     */
    state: 'created' | 'errored' | 'setup-pending' | 'setup' | 'pending';
    /**
     * The date and time the pipeline was created.
     */
    created_at: string;
    /**
     * A summary of the trigger.
     */
    trigger: {
        /**
         * The type of trigger.
         */
        type: 'scheduled_pipeline' | 'explicit' | 'api' | 'webhook';
        /**
         * The date and time the trigger was received.
         */
        received_at: string;
        /**
         * The user who triggered the Pipeline.
         */
        actor: {
            /**
             * The login information for the user on the VCS.
             */
            login: string;
            /**
             * URL to the user's avatar on the VCS
             */
            avatar_url: string;
        };
    };
    /**
     * VCS information for the pipeline.
     */
    vcs?: {
        /**
         * Name of the VCS provider (e.g. GitHub, Bitbucket).
         */
        provider_name: string;
        /**
         * URL for the repository the trigger targets (i.e. the repository where the PR will be merged). For fork-PR pipelines, this is the URL to the parent repo. For other pipelines, the `origin_` and `target_repository_url`s will be the same.
         */
        target_repository_url: string;
        /**
         * The branch where the pipeline ran. The HEAD commit on this branch was used for the pipeline. Note that `branch` and `tag` are mutually exclusive. To trigger a pipeline for a PR by number use `pull/<number>/head` for the PR ref or `pull/<number>/merge` for the merge ref (GitHub only).
         */
        branch?: string;
        /**
         * The code review id.
         */
        review_id?: string;
        /**
         * The code review URL.
         */
        review_url?: string;
        /**
         * The code revision the pipeline ran.
         */
        revision: string;
        /**
         * The tag used by the pipeline. The commit that this tag points to was used for the pipeline. Note that `branch` and `tag` are mutually exclusive.
         */
        tag?: string;
        /**
         * The latest commit in the pipeline.
         */
        commit?: {
            /**
             * The subject of the commit message.
             */
            subject: string;
            /**
             * The body of the commit message.
             */
            body: string;
        };
        /**
         * URL for the repository where the trigger originated. For fork-PR pipelines, this is the URL to the fork. For other pipelines the `origin_` and `target_repository_url`s will be the same.
         */
        origin_repository_url: string;
    };
};

export type GetPipelineByNumberError = {
    message?: string;
};

export type CreateScheduleData = {
    body?: {
        /**
         * Name of the schedule.
         */
        name: string;
        /**
         * Timetable that specifies when a schedule triggers.
         */
        timetable: {
    /**
     * Number of times a schedule triggers per hour, value must be between 1 and 60
     */
    'per-hour': number;
    /**
     * Hours in a day in which the schedule triggers.
     */
    'hours-of-day': Array<(number)>;
    /**
     * Days in a week in which the schedule triggers.
     */
    'days-of-week': Array<('TUE' | 'SAT' | 'SUN' | 'MON' | 'THU' | 'WED' | 'FRI')>;
    /**
     * Days in a month in which the schedule triggers. This is mutually exclusive with days in a week.
     */
    'days-of-month'?: Array<(number)>;
    /**
     * Months in which the schedule triggers.
     */
    months?: Array<('MAR' | 'NOV' | 'DEC' | 'JUN' | 'MAY' | 'OCT' | 'FEB' | 'APR' | 'SEP' | 'AUG' | 'JAN' | 'JUL')>;
} | {
    /**
     * Number of times a schedule triggers per hour, value must be between 1 and 60
     */
    'per-hour': number;
    /**
     * Hours in a day in which the schedule triggers.
     */
    'hours-of-day': Array<(number)>;
    /**
     * Days in a month in which the schedule triggers. This is mutually exclusive with days in a week.
     */
    'days-of-month': Array<(number)>;
    /**
     * Days in a week in which the schedule triggers.
     */
    'days-of-week'?: Array<('TUE' | 'SAT' | 'SUN' | 'MON' | 'THU' | 'WED' | 'FRI')>;
    /**
     * Months in which the schedule triggers.
     */
    months?: Array<('MAR' | 'NOV' | 'DEC' | 'JUN' | 'MAY' | 'OCT' | 'FEB' | 'APR' | 'SEP' | 'AUG' | 'JAN' | 'JUL')>;
};
        /**
         * The attribution-actor of the scheduled pipeline.
         */
        'attribution-actor': 'current' | 'system';
        /**
         * Pipeline parameters represented as key-value pairs. Must contain branch or tag.
         */
        parameters: {
            [key: string]: (number | string | boolean);
        };
        /**
         * Description of the schedule.
         */
        description?: string;
    };
    path: {
        /**
         * Project slug in the form `vcs-slug/org-name/repo-name`. The `/` characters may be URL-escaped. For projects that use GitLab or GitHub App, use `circleci` as the `vcs-slug`, replace `org-name` with the organization ID (found in Organization Settings), and replace `repo-name` with the project ID (found in Project Settings).
         */
        'project-slug': string;
    };
};

export type CreateScheduleResponse = {
    /**
     * The unique ID of the schedule.
     */
    id: string;
    /**
     * Timetable that specifies when a schedule triggers.
     */
    timetable: {
    /**
     * Number of times a schedule triggers per hour, value must be between 1 and 60
     */
    'per-hour': number;
    /**
     * Hours in a day in which the schedule triggers.
     */
    'hours-of-day': Array<(number)>;
    /**
     * Days in a week in which the schedule triggers.
     */
    'days-of-week': Array<('TUE' | 'SAT' | 'SUN' | 'MON' | 'THU' | 'WED' | 'FRI')>;
    /**
     * Days in a month in which the schedule triggers. This is mutually exclusive with days in a week.
     */
    'days-of-month'?: Array<(number)>;
    /**
     * Months in which the schedule triggers.
     */
    months?: Array<('MAR' | 'NOV' | 'DEC' | 'JUN' | 'MAY' | 'OCT' | 'FEB' | 'APR' | 'SEP' | 'AUG' | 'JAN' | 'JUL')>;
} | {
    /**
     * Number of times a schedule triggers per hour, value must be between 1 and 60
     */
    'per-hour': number;
    /**
     * Hours in a day in which the schedule triggers.
     */
    'hours-of-day': Array<(number)>;
    /**
     * Days in a month in which the schedule triggers. This is mutually exclusive with days in a week.
     */
    'days-of-month': Array<(number)>;
    /**
     * Days in a week in which the schedule triggers.
     */
    'days-of-week'?: Array<('TUE' | 'SAT' | 'SUN' | 'MON' | 'THU' | 'WED' | 'FRI')>;
    /**
     * Months in which the schedule triggers.
     */
    months?: Array<('MAR' | 'NOV' | 'DEC' | 'JUN' | 'MAY' | 'OCT' | 'FEB' | 'APR' | 'SEP' | 'AUG' | 'JAN' | 'JUL')>;
};
    /**
     * The date and time the pipeline was last updated.
     */
    'updated-at': string;
    /**
     * Name of the schedule.
     */
    name: string;
    /**
     * The date and time the pipeline was created.
     */
    'created-at': string;
    /**
     * The project-slug for the schedule
     */
    'project-slug': string;
    /**
     * Pipeline parameters represented as key-value pairs. Must contain branch or tag.
     */
    parameters: {
        [key: string]: (number | string | boolean);
    };
    /**
     * The attribution actor who will run the scheduled pipeline.
     */
    actor: {
        /**
         * The unique ID of the user.
         */
        id: string;
        /**
         * The login information for the user on the VCS.
         */
        login: string;
        /**
         * The name of the user.
         */
        name: string;
    };
    /**
     * Description of the schedule.
     */
    description: string;
};

export type CreateScheduleError = {
    message?: string;
};

export type ListSchedulesForProjectData = {
    path: {
        /**
         * Project slug in the form `vcs-slug/org-name/repo-name`. The `/` characters may be URL-escaped. For projects that use GitLab or GitHub App, use `circleci` as the `vcs-slug`, replace `org-name` with the organization ID (found in Organization Settings), and replace `repo-name` with the project ID (found in Project Settings).
         */
        'project-slug': string;
    };
    query?: {
        /**
         * A token to retrieve the next page of results.
         */
        'page-token'?: string;
    };
};

export type ListSchedulesForProjectResponse = {
    items: Array<{
        /**
         * The unique ID of the schedule.
         */
        id: string;
        /**
         * Timetable that specifies when a schedule triggers.
         */
        timetable: {
    /**
     * Number of times a schedule triggers per hour, value must be between 1 and 60
     */
    'per-hour': number;
    /**
     * Hours in a day in which the schedule triggers.
     */
    'hours-of-day': Array<(number)>;
    /**
     * Days in a week in which the schedule triggers.
     */
    'days-of-week': Array<('TUE' | 'SAT' | 'SUN' | 'MON' | 'THU' | 'WED' | 'FRI')>;
    /**
     * Days in a month in which the schedule triggers. This is mutually exclusive with days in a week.
     */
    'days-of-month'?: Array<(number)>;
    /**
     * Months in which the schedule triggers.
     */
    months?: Array<('MAR' | 'NOV' | 'DEC' | 'JUN' | 'MAY' | 'OCT' | 'FEB' | 'APR' | 'SEP' | 'AUG' | 'JAN' | 'JUL')>;
} | {
    /**
     * Number of times a schedule triggers per hour, value must be between 1 and 60
     */
    'per-hour': number;
    /**
     * Hours in a day in which the schedule triggers.
     */
    'hours-of-day': Array<(number)>;
    /**
     * Days in a month in which the schedule triggers. This is mutually exclusive with days in a week.
     */
    'days-of-month': Array<(number)>;
    /**
     * Days in a week in which the schedule triggers.
     */
    'days-of-week'?: Array<('TUE' | 'SAT' | 'SUN' | 'MON' | 'THU' | 'WED' | 'FRI')>;
    /**
     * Months in which the schedule triggers.
     */
    months?: Array<('MAR' | 'NOV' | 'DEC' | 'JUN' | 'MAY' | 'OCT' | 'FEB' | 'APR' | 'SEP' | 'AUG' | 'JAN' | 'JUL')>;
};
        /**
         * The date and time the pipeline was last updated.
         */
        'updated-at': string;
        /**
         * Name of the schedule.
         */
        name: string;
        /**
         * The date and time the pipeline was created.
         */
        'created-at': string;
        /**
         * The project-slug for the schedule
         */
        'project-slug': string;
        /**
         * Pipeline parameters represented as key-value pairs. Must contain branch or tag.
         */
        parameters: {
            [key: string]: (number | string | boolean);
        };
        /**
         * The attribution actor who will run the scheduled pipeline.
         */
        actor: {
            /**
             * The unique ID of the user.
             */
            id: string;
            /**
             * The login information for the user on the VCS.
             */
            login: string;
            /**
             * The name of the user.
             */
            name: string;
        };
        /**
         * Description of the schedule.
         */
        description: string;
    }>;
    /**
     * A token to pass as a `page-token` query parameter to return the next page of results.
     */
    next_page_token: string;
};

export type ListSchedulesForProjectError = {
    message?: string;
};

export type GetJobArtifactsData = {
    path: {
        /**
         * The number of the job.
         */
        'job-number': unknown;
        /**
         * Project slug in the form `vcs-slug/org-name/repo-name`. The `/` characters may be URL-escaped. For projects that use GitLab or GitHub App, use `circleci` as the `vcs-slug`, replace `org-name` with the organization ID (found in Organization Settings), and replace `repo-name` with the project ID (found in Project Settings).
         */
        'project-slug': string;
    };
};

export type GetJobArtifactsResponse = {
    items: Array<{
        /**
         * The artifact path.
         */
        path: string;
        /**
         * The index of the node that stored the artifact.
         */
        node_index: number;
        /**
         * The URL to download the artifact contents.
         */
        url: string;
    }>;
    /**
     * A token to pass as a `page-token` query parameter to return the next page of results.
     */
    next_page_token: string;
};

export type GetJobArtifactsError = {
    message?: string;
};

export type GetTestsData = {
    path: {
        /**
         * The number of the job.
         */
        'job-number': unknown;
        /**
         * Project slug in the form `vcs-slug/org-name/repo-name`. The `/` characters may be URL-escaped. For projects that use GitLab or GitHub App, use `circleci` as the `vcs-slug`, replace `org-name` with the organization ID (found in Organization Settings), and replace `repo-name` with the project ID (found in Project Settings).
         */
        'project-slug': string;
    };
};

export type GetTestsResponse = {
    items: Array<{
        /**
         * The failure message associated with the test.
         */
        message: string;
        /**
         * The program that generated the test results
         */
        source: string;
        /**
         * The time it took to run the test in seconds
         */
        run_time: number;
        /**
         * The file in which the test is defined.
         */
        file: string;
        /**
         * Indication of whether the test succeeded.
         */
        result: string;
        /**
         * The name of the test.
         */
        name: string;
        /**
         * The programmatic location of the test.
         */
        classname: string;
    }>;
    /**
     * A token to pass as a `page-token` query parameter to return the next page of results.
     */
    next_page_token: string;
};

export type GetTestsError = {
    message?: string;
};

export type DeleteScheduleByIdData = {
    path: {
        /**
         * The unique ID of the schedule.
         */
        'schedule-id': string;
    };
};

export type DeleteScheduleByIdResponse = {
    /**
     * A human-readable message
     */
    message: string;
};

export type DeleteScheduleByIdError = {
    message?: string;
};

export type UpdateScheduleData = {
    body?: {
        /**
         * Description of the schedule.
         */
        description?: string;
        /**
         * Name of the schedule.
         */
        name?: string;
        /**
         * Timetable that specifies when a schedule triggers.
         */
        timetable?: {
            /**
             * Number of times a schedule triggers per hour, value must be between 1 and 60
             */
            'per-hour'?: number;
            /**
             * Hours in a day in which the schedule triggers.
             */
            'hours-of-day'?: Array<(number)>;
            /**
             * Days in a week in which the schedule triggers.
             */
            'days-of-week'?: Array<('TUE' | 'SAT' | 'SUN' | 'MON' | 'THU' | 'WED' | 'FRI')>;
            /**
             * Days in a month in which the schedule triggers. This is mutually exclusive with days in a week.
             */
            'days-of-month'?: Array<(number)>;
            /**
             * Months in which the schedule triggers.
             */
            months?: Array<('MAR' | 'NOV' | 'DEC' | 'JUN' | 'MAY' | 'OCT' | 'FEB' | 'APR' | 'SEP' | 'AUG' | 'JAN' | 'JUL')>;
        };
        /**
         * The attribution-actor of the scheduled pipeline.
         */
        'attribution-actor'?: 'current' | 'system';
        /**
         * Pipeline parameters represented as key-value pairs. Must contain branch or tag.
         */
        parameters?: {
            [key: string]: (number | string | boolean);
        };
    };
    path: {
        /**
         * The unique ID of the schedule.
         */
        'schedule-id': string;
    };
};

export type UpdateScheduleResponse = {
    /**
     * The unique ID of the schedule.
     */
    id: string;
    /**
     * Timetable that specifies when a schedule triggers.
     */
    timetable: {
    /**
     * Number of times a schedule triggers per hour, value must be between 1 and 60
     */
    'per-hour': number;
    /**
     * Hours in a day in which the schedule triggers.
     */
    'hours-of-day': Array<(number)>;
    /**
     * Days in a week in which the schedule triggers.
     */
    'days-of-week': Array<('TUE' | 'SAT' | 'SUN' | 'MON' | 'THU' | 'WED' | 'FRI')>;
    /**
     * Days in a month in which the schedule triggers. This is mutually exclusive with days in a week.
     */
    'days-of-month'?: Array<(number)>;
    /**
     * Months in which the schedule triggers.
     */
    months?: Array<('MAR' | 'NOV' | 'DEC' | 'JUN' | 'MAY' | 'OCT' | 'FEB' | 'APR' | 'SEP' | 'AUG' | 'JAN' | 'JUL')>;
} | {
    /**
     * Number of times a schedule triggers per hour, value must be between 1 and 60
     */
    'per-hour': number;
    /**
     * Hours in a day in which the schedule triggers.
     */
    'hours-of-day': Array<(number)>;
    /**
     * Days in a month in which the schedule triggers. This is mutually exclusive with days in a week.
     */
    'days-of-month': Array<(number)>;
    /**
     * Days in a week in which the schedule triggers.
     */
    'days-of-week'?: Array<('TUE' | 'SAT' | 'SUN' | 'MON' | 'THU' | 'WED' | 'FRI')>;
    /**
     * Months in which the schedule triggers.
     */
    months?: Array<('MAR' | 'NOV' | 'DEC' | 'JUN' | 'MAY' | 'OCT' | 'FEB' | 'APR' | 'SEP' | 'AUG' | 'JAN' | 'JUL')>;
};
    /**
     * The date and time the pipeline was last updated.
     */
    'updated-at': string;
    /**
     * Name of the schedule.
     */
    name: string;
    /**
     * The date and time the pipeline was created.
     */
    'created-at': string;
    /**
     * The project-slug for the schedule
     */
    'project-slug': string;
    /**
     * Pipeline parameters represented as key-value pairs. Must contain branch or tag.
     */
    parameters: {
        [key: string]: (number | string | boolean);
    };
    /**
     * The attribution actor who will run the scheduled pipeline.
     */
    actor: {
        /**
         * The unique ID of the user.
         */
        id: string;
        /**
         * The login information for the user on the VCS.
         */
        login: string;
        /**
         * The name of the user.
         */
        name: string;
    };
    /**
     * Description of the schedule.
     */
    description: string;
};

export type UpdateScheduleError = {
    message?: string;
};

export type GetScheduleByIdData = {
    path: {
        /**
         * The unique ID of the schedule.
         */
        'schedule-id': string;
    };
};

export type GetScheduleByIdResponse = {
    /**
     * The unique ID of the schedule.
     */
    id: string;
    /**
     * Timetable that specifies when a schedule triggers.
     */
    timetable: {
    /**
     * Number of times a schedule triggers per hour, value must be between 1 and 60
     */
    'per-hour': number;
    /**
     * Hours in a day in which the schedule triggers.
     */
    'hours-of-day': Array<(number)>;
    /**
     * Days in a week in which the schedule triggers.
     */
    'days-of-week': Array<('TUE' | 'SAT' | 'SUN' | 'MON' | 'THU' | 'WED' | 'FRI')>;
    /**
     * Days in a month in which the schedule triggers. This is mutually exclusive with days in a week.
     */
    'days-of-month'?: Array<(number)>;
    /**
     * Months in which the schedule triggers.
     */
    months?: Array<('MAR' | 'NOV' | 'DEC' | 'JUN' | 'MAY' | 'OCT' | 'FEB' | 'APR' | 'SEP' | 'AUG' | 'JAN' | 'JUL')>;
} | {
    /**
     * Number of times a schedule triggers per hour, value must be between 1 and 60
     */
    'per-hour': number;
    /**
     * Hours in a day in which the schedule triggers.
     */
    'hours-of-day': Array<(number)>;
    /**
     * Days in a month in which the schedule triggers. This is mutually exclusive with days in a week.
     */
    'days-of-month': Array<(number)>;
    /**
     * Days in a week in which the schedule triggers.
     */
    'days-of-week'?: Array<('TUE' | 'SAT' | 'SUN' | 'MON' | 'THU' | 'WED' | 'FRI')>;
    /**
     * Months in which the schedule triggers.
     */
    months?: Array<('MAR' | 'NOV' | 'DEC' | 'JUN' | 'MAY' | 'OCT' | 'FEB' | 'APR' | 'SEP' | 'AUG' | 'JAN' | 'JUL')>;
};
    /**
     * The date and time the pipeline was last updated.
     */
    'updated-at': string;
    /**
     * Name of the schedule.
     */
    name: string;
    /**
     * The date and time the pipeline was created.
     */
    'created-at': string;
    /**
     * The project-slug for the schedule
     */
    'project-slug': string;
    /**
     * Pipeline parameters represented as key-value pairs. Must contain branch or tag.
     */
    parameters: {
        [key: string]: (number | string | boolean);
    };
    /**
     * The attribution actor who will run the scheduled pipeline.
     */
    actor: {
        /**
         * The unique ID of the user.
         */
        id: string;
        /**
         * The login information for the user on the VCS.
         */
        login: string;
        /**
         * The name of the user.
         */
        name: string;
    };
    /**
     * Description of the schedule.
     */
    description: string;
};

export type GetScheduleByIdError = {
    message?: string;
};

export type GetUserData = {
    path: {
        /**
         * The unique ID of the user.
         */
        id: string;
    };
};

export type GetUserResponse = {
    /**
     * The unique ID of the user.
     */
    id: string;
    /**
     * The login information for the user on the VCS.
     */
    login: string;
    /**
     * The name of the user.
     */
    name: string;
};

export type GetUserError = {
    message?: string;
};

export type GetWebhooksData = {
    query: {
        /**
         * ID of the scope being used (at the moment, only project ID is supported)
         */
        'scope-id': string;
        /**
         * Type of the scope being used
         */
        'scope-type': 'project';
    };
};

export type GetWebhooksResponse = {
    items: Array<{
        /**
         * URL to deliver the webhook to. Note: protocol must be included as well (only https is supported)
         */
        url: string;
        /**
         * Whether to enforce TLS certificate verification when delivering the webhook
         */
        'verify-tls': boolean;
        /**
         * The unique ID of the webhook
         */
        id: string;
        /**
         * Masked value of the secret used to build an HMAC hash of the payload and passed as a header in the webhook request
         */
        'signing-secret': string;
        /**
         * The date and time the webhook was last updated.
         */
        'updated-at': string;
        /**
         * Name of the webhook
         */
        name: string;
        /**
         * The date and time the webhook was created.
         */
        'created-at': string;
        /**
         * The scope in which the relevant events that will trigger webhooks
         */
        scope: {
            /**
             * ID of the scope being used (at the moment, only project ID is supported)
             */
            id: string;
            /**
             * Type of the scope being used
             */
            type: string;
        };
        /**
         * Events that will trigger the webhook
         */
        events: Array<('workflow-completed' | 'job-completed')>;
    }>;
    /**
     * A token to pass as a `page-token` query parameter to return the next page of results.
     */
    next_page_token: string;
};

export type GetWebhooksError = {
    message?: string;
};

export type CreateWebhookData = {
    body?: {
        /**
         * Name of the webhook
         */
        name: string;
        /**
         * Events that will trigger the webhook
         */
        events: Array<('workflow-completed' | 'job-completed')>;
        /**
         * URL to deliver the webhook to. Note: protocol must be included as well (only https is supported)
         */
        url: string;
        /**
         * Whether to enforce TLS certificate verification when delivering the webhook
         */
        'verify-tls': boolean;
        /**
         * Secret used to build an HMAC hash of the payload and passed as a header in the webhook request
         */
        'signing-secret': string;
        /**
         * The scope in which the relevant events that will trigger webhooks
         */
        scope: {
            /**
             * ID of the scope being used (at the moment, only project ID is supported)
             */
            id: string;
            /**
             * Type of the scope being used
             */
            type: 'project';
        };
    };
};

export type CreateWebhookResponse = {
    /**
     * URL to deliver the webhook to. Note: protocol must be included as well (only https is supported)
     */
    url: string;
    /**
     * Whether to enforce TLS certificate verification when delivering the webhook
     */
    'verify-tls': boolean;
    /**
     * The unique ID of the webhook
     */
    id: string;
    /**
     * Masked value of the secret used to build an HMAC hash of the payload and passed as a header in the webhook request
     */
    'signing-secret': string;
    /**
     * The date and time the webhook was last updated.
     */
    'updated-at': string;
    /**
     * Name of the webhook
     */
    name: string;
    /**
     * The date and time the webhook was created.
     */
    'created-at': string;
    /**
     * The scope in which the relevant events that will trigger webhooks
     */
    scope: {
        /**
         * ID of the scope being used (at the moment, only project ID is supported)
         */
        id: string;
        /**
         * Type of the scope being used
         */
        type: string;
    };
    /**
     * Events that will trigger the webhook
     */
    events: Array<('workflow-completed' | 'job-completed')>;
};

export type CreateWebhookError = {
    message?: string;
};

export type DeleteWebhookData = {
    path: {
        /**
         * ID of the webhook (UUID)
         */
        'webhook-id': string;
    };
};

export type DeleteWebhookResponse = {
    /**
     * A human-readable message
     */
    message: string;
};

export type DeleteWebhookError = {
    message?: string;
};

export type GetWebhookByIdData = {
    path: {
        /**
         * ID of the webhook (UUID)
         */
        'webhook-id': string;
    };
};

export type GetWebhookByIdResponse = {
    /**
     * URL to deliver the webhook to. Note: protocol must be included as well (only https is supported)
     */
    url: string;
    /**
     * Whether to enforce TLS certificate verification when delivering the webhook
     */
    'verify-tls': boolean;
    /**
     * The unique ID of the webhook
     */
    id: string;
    /**
     * Masked value of the secret used to build an HMAC hash of the payload and passed as a header in the webhook request
     */
    'signing-secret': string;
    /**
     * The date and time the webhook was last updated.
     */
    'updated-at': string;
    /**
     * Name of the webhook
     */
    name: string;
    /**
     * The date and time the webhook was created.
     */
    'created-at': string;
    /**
     * The scope in which the relevant events that will trigger webhooks
     */
    scope: {
        /**
         * ID of the scope being used (at the moment, only project ID is supported)
         */
        id: string;
        /**
         * Type of the scope being used
         */
        type: string;
    };
    /**
     * Events that will trigger the webhook
     */
    events: Array<('workflow-completed' | 'job-completed')>;
};

export type GetWebhookByIdError = {
    message?: string;
};

export type UpdateWebhookData = {
    body?: {
        /**
         * Name of the webhook
         */
        name?: string;
        /**
         * Events that will trigger the webhook
         */
        events?: Array<('workflow-completed' | 'job-completed')>;
        /**
         * URL to deliver the webhook to. Note: protocol must be included as well (only https is supported)
         */
        url?: string;
        /**
         * Secret used to build an HMAC hash of the payload and passed as a header in the webhook request
         */
        'signing-secret'?: string;
        /**
         * Whether to enforce TLS certificate verification when delivering the webhook
         */
        'verify-tls'?: boolean;
    };
    path: {
        /**
         * ID of the webhook (UUID)
         */
        'webhook-id': string;
    };
};

export type UpdateWebhookResponse = {
    /**
     * URL to deliver the webhook to. Note: protocol must be included as well (only https is supported)
     */
    url: string;
    /**
     * Whether to enforce TLS certificate verification when delivering the webhook
     */
    'verify-tls': boolean;
    /**
     * The unique ID of the webhook
     */
    id: string;
    /**
     * Masked value of the secret used to build an HMAC hash of the payload and passed as a header in the webhook request
     */
    'signing-secret': string;
    /**
     * The date and time the webhook was last updated.
     */
    'updated-at': string;
    /**
     * Name of the webhook
     */
    name: string;
    /**
     * The date and time the webhook was created.
     */
    'created-at': string;
    /**
     * The scope in which the relevant events that will trigger webhooks
     */
    scope: {
        /**
         * ID of the scope being used (at the moment, only project ID is supported)
         */
        id: string;
        /**
         * Type of the scope being used
         */
        type: string;
    };
    /**
     * Events that will trigger the webhook
     */
    events: Array<('workflow-completed' | 'job-completed')>;
};

export type UpdateWebhookError = {
    message?: string;
};

export type GetWorkflowByIdData = {
    path: {
        /**
         * The unique ID of the workflow.
         */
        id: string;
    };
};

export type GetWorkflowByIdResponse = {
    /**
     * The ID of the pipeline this workflow belongs to.
     */
    pipeline_id: string;
    canceled_by?: string;
    /**
     * The unique ID of the workflow.
     */
    id: string;
    /**
     * The name of the workflow.
     */
    name: string;
    /**
     * The project-slug for the pipeline this workflow belongs to.
     */
    project_slug: string;
    errored_by?: string;
    /**
     * Tag used for the workflow
     */
    tag?: 'setup';
    /**
     * The current status of the workflow.
     */
    status: 'success' | 'running' | 'not_run' | 'failed' | 'error' | 'failing' | 'on_hold' | 'canceled' | 'unauthorized';
    started_by: string;
    /**
     * The number of the pipeline this workflow belongs to.
     */
    pipeline_number: number;
    /**
     * The date and time the workflow was created.
     */
    created_at: string;
    /**
     * The date and time the workflow stopped.
     */
    stopped_at: string;
};

export type GetWorkflowByIdError = {
    message?: string;
};

export type ApprovePendingApprovalJobByIdData = {
    path: {
        /**
         * The ID of the job being approved.
         */
        approval_request_id: string;
        /**
         * The unique ID of the workflow.
         */
        id: string;
    };
};

export type ApprovePendingApprovalJobByIdResponse = {
    /**
     * A human-readable message
     */
    message: string;
};

export type ApprovePendingApprovalJobByIdError = {
    message?: string;
};

export type CancelWorkflowData = {
    path: {
        /**
         * The unique ID of the workflow.
         */
        id: string;
    };
};

export type CancelWorkflowResponse = {
    /**
     * A human-readable message
     */
    message: string;
};

export type CancelWorkflowError = {
    message?: string;
};

export type ListWorkflowJobsData = {
    path: {
        /**
         * The unique ID of the workflow.
         */
        id: string;
    };
};

export type ListWorkflowJobsResponse = {
    items: Array<{
        /**
         * The unique ID of the user.
         */
        canceled_by?: string;
        /**
         * A sequence of the unique job IDs for the jobs that this job depends upon in the workflow.
         */
        dependencies: Array<(string)>;
        /**
         * The number of the job.
         */
        job_number?: number;
        /**
         * The unique ID of the job.
         */
        id: string;
        /**
         * The date and time the job started.
         */
        started_at: string;
        /**
         * The name of the job.
         */
        name: string;
        /**
         * The unique ID of the user.
         */
        approved_by?: string;
        /**
         * The project-slug for the job.
         */
        project_slug: string;
        /**
         * The current status of the job.
         */
        status: 'success' | 'running' | 'not_run' | 'failed' | 'retried' | 'queued' | 'not_running' | 'infrastructure_fail' | 'timedout' | 'on_hold' | 'terminated-unknown' | 'blocked' | 'canceled' | 'unauthorized';
        /**
         * The type of job.
         */
        type: 'build' | 'approval';
        /**
         * The time when the job stopped.
         */
        stopped_at?: string;
        /**
         * The unique ID of the job.
         */
        approval_request_id?: string;
    }>;
    /**
     * A token to pass as a `page-token` query parameter to return the next page of results.
     */
    next_page_token: string;
};

export type ListWorkflowJobsError = {
    message?: string;
};

export type RerunWorkflowData = {
    body?: {
        /**
         * Whether to enable SSH access for the triggering user on the newly-rerun job. Requires the jobs parameter to be used and so is mutually exclusive with the from_failed parameter.
         */
        enable_ssh?: boolean;
        /**
         * Whether to rerun the workflow from the failed job. Mutually exclusive with the jobs parameter.
         */
        from_failed?: boolean;
        /**
         * A list of job IDs to rerun.
         */
        jobs?: Array<(string)>;
        /**
         * Completes rerun using sparse trees logic, an optimization for workflows that have disconnected subgraphs. Requires jobs parameter and so is mutually exclusive with the from_failed parameter.
         */
        sparse_tree?: boolean;
    };
    path: {
        /**
         * The unique ID of the workflow.
         */
        id: string;
    };
};

export type RerunWorkflowResponse = {
    /**
     * The ID of the newly-created workflow.
     */
    workflow_id: string;
};

export type RerunWorkflowError = {
    message?: string;
};

export type DeleteOrgClaimsData = {
    path: {
        orgID: string;
    };
    query: {
        /**
         * comma separated list of claims to delete. Valid values are "audience" and "ttl".
         */
        claims: string;
    };
};

export type DeleteOrgClaimsResponse = ClaimResponse;

export type DeleteOrgClaimsError = {
    error: string;
};

export type GetOrgClaimsData = {
    path: {
        orgID: string;
    };
};

export type GetOrgClaimsResponse = ClaimResponse;

export type GetOrgClaimsError = {
    error: string;
};

export type PatchOrgClaimsData = {
    body?: PatchClaimsRequest;
    path: {
        orgID: string;
    };
};

export type PatchOrgClaimsResponse = ClaimResponse;

export type PatchOrgClaimsError = {
    error: string;
};

export type DeleteProjectClaimsData = {
    path: {
        orgID: string;
        projectID: string;
    };
    query: {
        /**
         * comma separated list of claims to delete. Valid values are "audience" and "ttl".
         */
        claims: string;
    };
};

export type DeleteProjectClaimsResponse = ClaimResponse;

export type DeleteProjectClaimsError = {
    error: string;
};

export type GetProjectClaimsData = {
    path: {
        orgID: string;
        projectID: string;
    };
};

export type GetProjectClaimsResponse = ClaimResponse;

export type GetProjectClaimsError = {
    error: string;
};

export type PatchProjectClaimsData = {
    body?: PatchClaimsRequest;
    path: {
        orgID: string;
        projectID: string;
    };
};

export type PatchProjectClaimsResponse = ClaimResponse;

export type PatchProjectClaimsError = {
    error: string;
};

export type GetDecisionLogsData = {
    path: {
        context: string;
        ownerID: string;
    };
    query?: {
        /**
         * Return decisions made after this date.
         */
        after?: string;
        /**
         * Return decisions made before this date.
         */
        before?: string;
        /**
         * Return decisions made on this branch.
         */
        branch?: string;
        /**
         * Return decisions made for this build number.
         */
        build_number?: string;
        /**
         * Sets the offset when retrieving the decisions, for paging.
         */
        offset?: number;
        /**
         * Return decisions made for this project.
         */
        project_id?: string;
        /**
         * Return decisions matching this decision status.
         */
        status?: string;
    };
};

export type GetDecisionLogsResponse = Array<DecisionLog>;

export type GetDecisionLogsError = {
    error: string;
};

export type MakeDecisionData = {
    body?: {
        input: string;
        metadata?: {
            [key: string]: unknown;
        };
    };
    path: {
        context: string;
        ownerID: string;
    };
};

export type MakeDecisionResponse = Decision;

export type MakeDecisionError = {
    error: string;
};

export type GetDecisionSettingsData = {
    path: {
        context: string;
        ownerID: string;
    };
};

export type GetDecisionSettingsResponse = DecisionSettings;

export type GetDecisionSettingsError = {
    error: string;
};

export type SetDecisionSettingsData = {
    body?: DecisionSettings;
    path: {
        context: string;
        ownerID: string;
    };
};

export type SetDecisionSettingsResponse = DecisionSettings;

export type SetDecisionSettingsError = {
    error: string;
};

export type GetDecisionLogData = {
    path: {
        context: string;
        decisionID: string;
        ownerID: string;
    };
};

export type GetDecisionLogResponse = DecisionLog;

export type GetDecisionLogError = {
    error: string;
};

export type GetDecisionLogPolicyBundleData = {
    path: {
        context: string;
        decisionID: string;
        ownerID: string;
    };
};

export type GetDecisionLogPolicyBundleResponse = PolicyBundle;

export type GetDecisionLogPolicyBundleError = {
    error: string;
};

export type GetPolicyBundleData = {
    path: {
        context: string;
        ownerID: string;
    };
};

export type GetPolicyBundleResponse = PolicyBundle;

export type GetPolicyBundleError = {
    error: string;
};

export type CreatePolicyBundleData = {
    body?: BundlePayload;
    path: {
        context: string;
        ownerID: string;
    };
    query?: {
        dry?: boolean;
    };
};

export type CreatePolicyBundleResponse = BundleDiff;

export type CreatePolicyBundleError = {
    error: string;
};

export type GetPolicyDocumentData = {
    path: {
        context: string;
        ownerID: string;
        /**
         * the policy name set by the rego policy_name rule
         */
        policyName: string;
    };
};

export type GetPolicyDocumentResponse = Policy;

export type GetPolicyDocumentError = {
    error: string;
};

export type GetContextRestrictionsData = {
    path: {
        /**
         * An opaque identifier of a context.
         */
        context_id: string;
    };
};

export type GetContextRestrictionsResponse = context_project_restrictions_list;

export type GetContextRestrictionsError = {
    message?: string;
};

export type CreateContextRestrictionData = {
    body: {
        /**
         * Deprecated - Use "restriction_type" and "restriction_value"
         * instead.
         *
         * The project ID to use for a project restriction. This is
         * mutually exclusive with restriction_type and restriction_value
         * and implies restriction_type is "project".
         *
         * @deprecated
         */
        project_id?: string;
        restriction_type?: string;
        restriction_value?: string;
    };
    path: {
        /**
         * An opaque identifier of a context.
         */
        context_id: string;
    };
};

export type CreateContextRestrictionResponse = restriction_created;

export type CreateContextRestrictionError = {
    message?: string;
};

export type DeleteContextRestrictionData = {
    path: {
        /**
         * An opaque identifier of a context.
         */
        context_id: string;
        /**
         * An opaque identifier of a context restriction.
         */
        restriction_id: string;
    };
};

export type DeleteContextRestrictionResponse = restriction_deleted;

export type DeleteContextRestrictionError = {
    message?: string;
};

export type CreateProjectData = {
    path: {
        /**
         * The `organization` segment of a project or org slug, the second of the three. For GitHub OAuth or Bitbucket projects, this is the organization name. For projects that use GitLab or GitHub App, use the organization ID (found in Organization Settings).
         */
        organization: string;
        /**
         * The `project` segment of a project slug, the third of the three. For GitHub OAuth or Bitbucket projects, this is the repository name. For projects that use GitLab or GitHub App, use the project ID (found in Project Settings).
         */
        project: string;
        /**
         * The `provider` segment of a project or org slug, the first of the three. This may be a VCS. For projects that use GitLab or GitHub App, use `circleci`.
         */
        provider: string;
    };
};

export type CreateProjectResponse = project_settings;

export type CreateProjectError = {
    message?: string;
};

export type GetProjectSettingsData = {
    path: {
        /**
         * The `organization` segment of a project or org slug, the second of the three. For GitHub OAuth or Bitbucket projects, this is the organization name. For projects that use GitLab or GitHub App, use the organization ID (found in Organization Settings).
         */
        organization: string;
        /**
         * The `project` segment of a project slug, the third of the three. For GitHub OAuth or Bitbucket projects, this is the repository name. For projects that use GitLab or GitHub App, use the project ID (found in Project Settings).
         */
        project: string;
        /**
         * The `provider` segment of a project or org slug, the first of the three. This may be a VCS. For projects that use GitLab or GitHub App, use `circleci`.
         */
        provider: string;
    };
};

export type GetProjectSettingsResponse = project_settings;

export type GetProjectSettingsError = {
    message?: string;
};

export type PatchProjectSettingsData = {
    /**
     * The setting(s) to update, including one or more fields in the JSON object. Note that `oss: true` will only be set on projects whose underlying repositories are actually open source.
     */
    body: project_settings;
    path: {
        /**
         * The `organization` segment of a project or org slug, the second of the three. For GitHub OAuth or Bitbucket projects, this is the organization name. For projects that use GitLab or GitHub App, use the organization ID (found in Organization Settings).
         */
        organization: string;
        /**
         * The `project` segment of a project slug, the third of the three. For GitHub OAuth or Bitbucket projects, this is the repository name. For projects that use GitLab or GitHub App, use the project ID (found in Project Settings).
         */
        project: string;
        /**
         * The `provider` segment of a project or org slug, the first of the three. This may be a VCS. For projects that use GitLab or GitHub App, use `circleci`.
         */
        provider: string;
    };
};

export type PatchProjectSettingsResponse = project_settings;

export type PatchProjectSettingsError = {
    message?: string;
};

export type CreateUsageExportData = {
    body: {
        /**
         * The start date & time (inclusive) of the range from which data will be pulled. Must be no more than one year ago.
         */
        start: string;
        /**
         * The end date & time (inclusive) of the range from which data will be pulled. Must be no more than 31 days after `start`.
         */
        end: string;
        shared_org_ids?: Array<(string)>;
    };
    path: {
        /**
         * An opaque identifier of an organization.
         */
        org_id: string;
    };
};

export type CreateUsageExportResponse = usage_export_job;

export type CreateUsageExportError = {
    message?: string;
};

export type GetUsageExportData = {
    path: {
        /**
         * An opaque identifier of an organization.
         */
        org_id: string;
        /**
         * An opaque identifier of a usage export job.
         */
        usage_export_job_id: string;
    };
};

export type GetUsageExportResponse = get_usage_export_job_status;

export type GetUsageExportError = {
    message?: string;
};

export type $OpenApiTs = {
    '/context': {
        post: {
            req: CreateContextData;
            res: {
                /**
                 * The new context
                 */
                '200': {
                    /**
                     * The unique ID of the context.
                     */
                    id: string;
                    /**
                     * The user defined name of the context.
                     */
                    name: string;
                    /**
                     * The date and time the context was created.
                     */
                    created_at: string;
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
        get: {
            req: ListContextsData;
            res: {
                /**
                 * A paginated list of contexts
                 */
                '200': {
                    items: Array<{
                        /**
                         * The unique ID of the context.
                         */
                        id: string;
                        /**
                         * The user defined name of the context.
                         */
                        name: string;
                        /**
                         * The date and time the context was created.
                         */
                        created_at: string;
                    }>;
                    /**
                     * A token to pass as a `page-token` query parameter to return the next page of results.
                     */
                    next_page_token: string;
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
    };
    '/context/{context-id}': {
        get: {
            req: GetContextData;
            res: {
                /**
                 * The context
                 */
                '200': {
                    /**
                     * The unique ID of the context.
                     */
                    id: string;
                    /**
                     * The user defined name of the context.
                     */
                    name: string;
                    /**
                     * The date and time the context was created.
                     */
                    created_at: string;
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
        delete: {
            req: DeleteContextData;
            res: {
                /**
                 * A confirmation message
                 */
                '200': {
                    /**
                     * A human-readable message
                     */
                    message: string;
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
    };
    '/context/{context-id}/environment-variable': {
        get: {
            req: ListEnvironmentVariablesFromContextData;
            res: {
                /**
                 * A paginated list of environment variables
                 */
                '200': {
                    items: Array<{
                        /**
                         * The name of the environment variable
                         */
                        variable: string;
                        /**
                         * The date and time the environment variable was created.
                         */
                        created_at: string;
                        /**
                         * The date and time the environment variable was updated
                         */
                        updated_at: string;
                        /**
                         * ID of the context (UUID)
                         */
                        context_id: string;
                    }>;
                    /**
                     * A token to pass as a `page-token` query parameter to return the next page of results.
                     */
                    next_page_token: string;
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
    };
    '/context/{context-id}/environment-variable/{env-var-name}': {
        delete: {
            req: DeleteEnvironmentVariableFromContextData;
            res: {
                /**
                 * A confirmation message
                 */
                '200': {
                    /**
                     * A human-readable message
                     */
                    message: string;
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
        put: {
            req: AddEnvironmentVariableToContextData;
            res: {
                /**
                 * The new environment variable
                 */
                '200': {
    /**
     * The name of the environment variable
     */
    variable: string;
    /**
     * The date and time the environment variable was created.
     */
    created_at: string;
    /**
     * The date and time the environment variable was updated
     */
    updated_at: string;
    /**
     * ID of the context (UUID)
     */
    context_id: string;
} | {
    /**
     * A human-readable message
     */
    message: string;
};
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
    };
    '/insights/pages/{project-slug}/summary': {
        get: {
            req: GetProjectWorkflowsPageDataData;
            res: {
                /**
                 * Aggregated summary metrics and trends by workflow and branches
                 */
                '200': {
                    /**
                     * The unique ID of the organization
                     */
                    org_id?: unknown;
                    /**
                     * The unique ID of the project
                     */
                    project_id?: unknown;
                    /**
                     * Metrics and trends data aggregated for a given project.
                     */
                    project_data?: {
                        /**
                         * Metrics aggregated across all workflows and branches for a project.
                         */
                        metrics: {
                            /**
                             * The total number of runs, including runs that are still on-hold or running.
                             */
                            total_runs: number;
                            /**
                             * Total duration, in seconds.
                             */
                            total_duration_secs: number;
                            /**
                             * The total credits consumed over the current timeseries interval.
                             */
                            total_credits_used: number;
                            success_rate: number;
                            /**
                             * The average number of runs per day.
                             */
                            throughput: number;
                        };
                        /**
                         * Metric trends aggregated across all workflows and branches for a project.
                         */
                        trends: {
                            /**
                             * The trend value for total number of runs.
                             */
                            total_runs: number;
                            /**
                             * Trend value for total duration.
                             */
                            total_duration_secs: number;
                            /**
                             * The trend value for total credits consumed.
                             */
                            total_credits_used: number;
                            /**
                             * The trend value for the success rate.
                             */
                            success_rate: number;
                            /**
                             * Trend value for the average number of runs per day.
                             */
                            throughput: number;
                        };
                    };
                    /**
                     * A list of metrics and trends data for workflows for a given project.
                     */
                    project_workflow_data?: Array<{
                        /**
                         * The name of the workflow.
                         */
                        workflow_name: string;
                        /**
                         * Metrics aggregated across a workflow or branchfor a project.
                         */
                        metrics: {
                            /**
                             * The total credits consumed over the current timeseries interval.
                             */
                            total_credits_used: number;
                            /**
                             * The 95th percentile duration among a group of workflow runs.
                             */
                            p95_duration_secs: number;
                            /**
                             * The total number of runs, including runs that are still on-hold or running.
                             */
                            total_runs: number;
                            success_rate: number;
                        };
                        /**
                         * Trends aggregated across a workflow or branch for a project.
                         */
                        trends: {
                            /**
                             * The trend value for total credits consumed.
                             */
                            total_credits_used: number;
                            /**
                             * The 95th percentile duration among a group of workflow runs.
                             */
                            p95_duration_secs: number;
                            /**
                             * The trend value for total number of runs.
                             */
                            total_runs: number;
                            /**
                             * The trend value for the success rate.
                             */
                            success_rate: number;
                        };
                    }>;
                    /**
                     * A list of metrics and trends data for branches for a given project.
                     */
                    project_workflow_branch_data?: Array<{
                        /**
                         * The name of the workflow.
                         */
                        workflow_name: string;
                        /**
                         * The VCS branch of a workflow's trigger.
                         */
                        branch: string;
                        /**
                         * Metrics aggregated across a workflow or branchfor a project.
                         */
                        metrics: {
                            /**
                             * The total credits consumed over the current timeseries interval.
                             */
                            total_credits_used: number;
                            /**
                             * The 95th percentile duration among a group of workflow runs.
                             */
                            p95_duration_secs: number;
                            /**
                             * The total number of runs, including runs that are still on-hold or running.
                             */
                            total_runs: number;
                            success_rate: number;
                        };
                        /**
                         * Trends aggregated across a workflow or branch for a project.
                         */
                        trends: {
                            /**
                             * The trend value for total credits consumed.
                             */
                            total_credits_used: number;
                            /**
                             * The 95th percentile duration among a group of workflow runs.
                             */
                            p95_duration_secs: number;
                            /**
                             * The trend value for total number of runs.
                             */
                            total_runs: number;
                            /**
                             * The trend value for the success rate.
                             */
                            success_rate: number;
                        };
                    }>;
                    /**
                     * A list of all the branches for a given project.
                     */
                    all_branches?: Array<(string)>;
                    /**
                     * A list of all the workflows for a given project.
                     */
                    all_workflows?: Array<(string)>;
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
    };
    '/insights/time-series/{project-slug}/workflows/{workflow-name}/jobs': {
        get: {
            req: GetJobTimeseriesData;
            res: {
                /**
                 * An array of timeseries data, one entry per job.
                 */
                '200': {
                    /**
                     * A token to pass as a `page-token` query parameter to return the next page of results.
                     */
                    next_page_token: string;
                    /**
                     * Aggregate metrics for a workflow at a time granularity
                     */
                    items: Array<{
                        /**
                         * The name of the workflow.
                         */
                        name: string;
                        /**
                         * The start time for the earliest execution included in the metrics.
                         */
                        min_started_at: string;
                        /**
                         * The end time of the last execution included in the metrics.
                         */
                        max_ended_at: string;
                        /**
                         * The start of the interval for timeseries metrics.
                         */
                        timestamp: string;
                        /**
                         * Metrics relating to a workflow's runs.
                         */
                        metrics: {
                            /**
                             * The total number of runs, including runs that are still on-hold or running.
                             */
                            total_runs: number;
                            /**
                             * The number of failed runs.
                             */
                            failed_runs: number;
                            /**
                             * The number of successful runs.
                             */
                            successful_runs: number;
                            /**
                             * The average number of runs per day.
                             */
                            throughput: number;
                            /**
                             * The median credits consumed over the current timeseries interval.
                             */
                            median_credits_used: number;
                            /**
                             * The total credits consumed over the current timeseries interval.
                             */
                            total_credits_used: number;
                            /**
                             * Metrics relating to the duration of runs for a workflow.
                             */
                            duration_metrics: {
                                /**
                                 * The minimum duration, in seconds, among a group of runs.
                                 */
                                min: number;
                                /**
                                 * The median duration, in seconds, among a group of runs.
                                 */
                                median: number;
                                /**
                                 * The max duration, in seconds, among a group of runs.
                                 */
                                max: number;
                                /**
                                 * The 95th percentile duration, in seconds, among a group of runs.
                                 */
                                p95: number;
                                /**
                                 * The total duration, in seconds, added across a group of runs.
                                 */
                                total: number;
                            };
                        };
                    }>;
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
    };
    '/insights/{org-slug}/summary': {
        get: {
            req: GetOrgSummaryDataData;
            res: {
                /**
                 * summary metrics with trends for an entire org and it's projects.
                 */
                '200': {
                    /**
                     * Aggregated metrics for an org, with trends.
                     */
                    org_data: {
                        /**
                         * Metrics for a single org metrics.
                         */
                        metrics: {
                            /**
                             * The total number of runs, including runs that are still on-hold or running.
                             */
                            total_runs: number;
                            /**
                             * Total duration, in seconds.
                             */
                            total_duration_secs: number;
                            /**
                             * The total credits consumed over the current timeseries interval.
                             */
                            total_credits_used: number;
                            success_rate: number;
                            /**
                             * The average number of runs per day.
                             */
                            throughput: number;
                        };
                        /**
                         * Trends for a single org.
                         */
                        trends: {
                            /**
                             * The trend value for total number of runs.
                             */
                            total_runs: number;
                            /**
                             * Trend value for total duration.
                             */
                            total_duration_secs: number;
                            /**
                             * The trend value for total credits consumed.
                             */
                            total_credits_used: number;
                            /**
                             * The trend value for the success rate.
                             */
                            success_rate: number;
                            /**
                             * Trend value for the average number of runs per day.
                             */
                            throughput: number;
                        };
                    };
                    /**
                     * Metrics for a single project, across all branches
                     */
                    org_project_data: Array<{
                        /**
                         * The name of the project.
                         */
                        project_name: string;
                        /**
                         * Metrics for a single project, across all branches.
                         */
                        metrics: {
                            /**
                             * The total credits consumed over the current timeseries interval.
                             */
                            total_credits_used: number;
                            /**
                             * Total duration, in seconds.
                             */
                            total_duration_secs: number;
                            /**
                             * The total number of runs, including runs that are still on-hold or running.
                             */
                            total_runs: number;
                            success_rate: number;
                        };
                        /**
                         * Trends for a single project, across all branches.
                         */
                        trends: {
                            /**
                             * The trend value for total credits consumed.
                             */
                            total_credits_used: number;
                            /**
                             * Trend value for total duration.
                             */
                            total_duration_secs: number;
                            /**
                             * The trend value for total number of runs.
                             */
                            total_runs: number;
                            /**
                             * The trend value for the success rate.
                             */
                            success_rate: number;
                        };
                    }>;
                    /**
                     * A list of all the project names in the organization.
                     */
                    all_projects: Array<(string)>;
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
    };
    '/insights/{project-slug}/branches': {
        get: {
            req: GetAllInsightsBranchesData;
            res: {
                /**
                 * A list of branches for a project
                 */
                '200': {
                    /**
                     * The unique ID of the organization
                     */
                    org_id: unknown;
                    /**
                     * The unique ID of the project
                     */
                    project_id: unknown;
                    /**
                     * A list of all the branches for a given project.
                     */
                    branches: Array<(string)>;
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
    };
    '/insights/{project-slug}/flaky-tests': {
        get: {
            req: GetFlakyTestsData;
            res: {
                /**
                 * A list of flaky tests for a project
                 */
                '200': {
                    /**
                     * A list of all instances of flakes. Note that a test is no longer considered flaky after 2 weeks have passed without a flake. Each flake resets this timer.
                     */
                    'flaky-tests': Array<{
                        'time-wasted'?: number;
                        /**
                         * The date and time when workflow was created.
                         */
                        'workflow-created-at': string;
                        /**
                         * The ID of the workflow associated with the provided test counts
                         */
                        'workflow-id': unknown;
                        /**
                         * The class the test belongs to.
                         */
                        classname: string;
                        /**
                         * The number of the pipeline.
                         */
                        'pipeline-number': number;
                        /**
                         * The name of the workflow.
                         */
                        'workflow-name': string;
                        /**
                         * The name of the test.
                         */
                        'test-name': string;
                        /**
                         * The name of the job.
                         */
                        'job-name': string;
                        /**
                         * The number of the job.
                         */
                        'job-number': number;
                        /**
                         * The number of times the test flaked.
                         */
                        'times-flaked': number;
                        /**
                         * The source of the test.
                         */
                        source: string;
                        /**
                         * The file the test belongs to.
                         */
                        file: string;
                    }>;
                    /**
                     * A count of unique tests that have failed. If your project has N tests that have flaked multiple times each, this will be equal to N.
                     */
                    'total-flaky-tests': number;
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
    };
    '/insights/{project-slug}/workflows': {
        get: {
            req: GetProjectWorkflowMetricsData;
            res: {
                /**
                 * A paginated list of summary metrics by workflow
                 */
                '200': {
                    /**
                     * Workflow summary metrics.
                     */
                    items: Array<{
                        /**
                         * The name of the workflow.
                         */
                        name: string;
                        /**
                         * Metrics relating to a workflow's runs.
                         */
                        metrics: {
                            /**
                             * The total number of runs, including runs that are still on-hold or running.
                             */
                            total_runs: number;
                            /**
                             * The number of successful runs.
                             */
                            successful_runs: number;
                            /**
                             * The mean time to recovery (mean time between failures and their next success) in seconds.
                             */
                            mttr: number;
                            /**
                             * The total credits consumed by the workflow in the aggregation window. Note that Insights is not a real time financial reporting tool and should not be used for credit reporting.
                             */
                            total_credits_used: number;
                            /**
                             * The number of failed runs.
                             */
                            failed_runs: number;
                            success_rate: number;
                            /**
                             * Metrics relating to the duration of runs for a workflow.
                             */
                            duration_metrics: {
                                /**
                                 * The minimum duration, in seconds, among a group of runs.
                                 */
                                min: number;
                                /**
                                 * The mean duration, in seconds, among a group of runs.
                                 */
                                mean: number;
                                /**
                                 * The median duration, in seconds, among a group of runs.
                                 */
                                median: number;
                                /**
                                 * The 95th percentile duration, in seconds, among a group of runs.
                                 */
                                p95: number;
                                /**
                                 * The max duration, in seconds, among a group of runs.
                                 */
                                max: number;
                                /**
                                 * The standard deviation, in seconds, among a group of runs.
                                 */
                                standard_deviation: number;
                            };
                            /**
                             * The number of recovered workflow executions per day.
                             */
                            total_recoveries: number;
                            /**
                             * The average number of runs per day.
                             */
                            throughput: number;
                        };
                        /**
                         * The timestamp of the first build within the requested reporting window.
                         */
                        window_start: string;
                        /**
                         * The timestamp of the last build within the requested reporting window.
                         */
                        window_end: string;
                        /**
                         * The unique ID of the project
                         */
                        project_id: unknown;
                    }>;
                    /**
                     * A token to pass as a `page-token` query parameter to return the next page of results.
                     */
                    next_page_token: string;
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
    };
    '/insights/{project-slug}/workflows/{workflow-name}': {
        get: {
            req: GetProjectWorkflowRunsData;
            res: {
                /**
                 * A paginated list of recent workflow runs
                 */
                '200': {
                    /**
                     * Recent workflow runs.
                     */
                    items: Array<{
                        /**
                         * The unique ID of the workflow.
                         */
                        id: string;
                        /**
                         * The VCS branch of a Workflow's trigger.
                         */
                        branch: string;
                        /**
                         * The duration in seconds of a run.
                         */
                        duration: number;
                        /**
                         * The date and time the workflow was created.
                         */
                        created_at: string;
                        /**
                         * The date and time the workflow stopped.
                         */
                        stopped_at: string;
                        /**
                         * The number of credits used during execution. Note that Insights is not a real time financial reporting tool and should not be used for credit reporting.
                         */
                        credits_used: number;
                        /**
                         * Workflow status.
                         */
                        status: 'success' | 'failed' | 'error' | 'canceled' | 'unauthorized';
                        /**
                         * Describes if the job is an approval job or not. Approval jobs are intermediary jobs that are created to pause the workflow until approved.
                         */
                        is_approval: boolean;
                    }>;
                    /**
                     * A token to pass as a `page-token` query parameter to return the next page of results.
                     */
                    next_page_token: string;
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
    };
    '/insights/{project-slug}/workflows/{workflow-name}/jobs': {
        get: {
            req: GetProjectWorkflowJobMetricsData;
            res: {
                /**
                 * A paginated list of summary metrics by workflow job.
                 */
                '200': {
                    /**
                     * Job summary metrics.
                     */
                    items: Array<{
                        /**
                         * The name of the job.
                         */
                        name: string;
                        /**
                         * Metrics relating to a workflow job's runs.
                         */
                        metrics: {
                            /**
                             * The total number of runs, including runs that are still on-hold or running.
                             */
                            total_runs: number;
                            /**
                             * The number of failed runs.
                             */
                            failed_runs: number;
                            /**
                             * The number of successful runs.
                             */
                            successful_runs: number;
                            /**
                             * Metrics relating to the duration of runs for a workflow job.
                             */
                            duration_metrics: {
                                /**
                                 * The minimum duration, in seconds, among a group of runs.
                                 */
                                min: number;
                                /**
                                 * The mean duration, in seconds, among a group of runs.
                                 */
                                mean: number;
                                /**
                                 * The median duration, in seconds, among a group of runs.
                                 */
                                median: number;
                                /**
                                 * The 95th percentile duration, in seconds, among a group of runs.
                                 */
                                p95: number;
                                /**
                                 * The max duration, in seconds, among a group of runs.
                                 */
                                max: number;
                                /**
                                 * The standard deviation, in seconds, among a group of runs.
                                 */
                                standard_deviation: number;
                            };
                            success_rate: number;
                            /**
                             * The total credits consumed by the job in the aggregation window. Note that Insights is not a real time financial reporting tool and should not be used for credit reporting.
                             */
                            total_credits_used: number;
                            /**
                             * The average number of runs per day.
                             */
                            throughput: number;
                        };
                        /**
                         * The timestamp of the first build within the requested reporting window.
                         */
                        window_start: string;
                        /**
                         * The timestamp of the last build within the requested reporting window.
                         */
                        window_end: string;
                    }>;
                    /**
                     * A token to pass as a `page-token` query parameter to return the next page of results.
                     */
                    next_page_token: string;
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
    };
    '/insights/{project-slug}/workflows/{workflow-name}/summary': {
        get: {
            req: GetWorkflowSummaryData;
            res: {
                /**
                 * Metrics and trends for a workflow
                 */
                '200': {
                    /**
                     * Metrics aggregated across a workflow for a given time window.
                     */
                    metrics: {
                        /**
                         * The total number of runs, including runs that are still on-hold or running.
                         */
                        total_runs: number;
                        /**
                         * The number of successful runs.
                         */
                        successful_runs: number;
                        /**
                         * The mean time to recovery (mean time between failures and their next success) in seconds.
                         */
                        mttr: number;
                        /**
                         * The total credits consumed by the workflow in the aggregation window. Note that Insights is not a real time financial reporting tool and should not be used for credit reporting.
                         */
                        total_credits_used: number;
                        /**
                         * The number of failed runs.
                         */
                        failed_runs: number;
                        success_rate: number;
                        /**
                         * The number of runs that ran to completion within the aggregation window
                         */
                        completed_runs: number;
                        /**
                         * The timestamp of the first build within the requested reporting window.
                         */
                        window_start: string;
                        /**
                         * Metrics relating to the duration of runs for a workflow.
                         */
                        duration_metrics: {
                            /**
                             * The minimum duration, in seconds, among a group of runs.
                             */
                            min: number;
                            /**
                             * The mean duration, in seconds, among a group of runs.
                             */
                            mean: number;
                            /**
                             * The median duration, in seconds, among a group of runs.
                             */
                            median: number;
                            /**
                             * The 95th percentile duration, in seconds, among a group of runs.
                             */
                            p95: number;
                            /**
                             * The max duration, in seconds, among a group of runs.
                             */
                            max: number;
                            /**
                             * The standard deviation, in seconds, among a group of runs.
                             */
                            standard_deviation: number;
                        };
                        /**
                         * The timestamp of the last build within the requested reporting window.
                         */
                        window_end: string;
                        /**
                         * The average number of runs per day.
                         */
                        throughput: number;
                    };
                    /**
                     * Trends for aggregated metrics across a workflow for a given time window.
                     */
                    trends: {
                        /**
                         * The trend value for total number of runs.
                         */
                        total_runs: number;
                        /**
                         * The trend value for number of failed runs.
                         */
                        failed_runs: number;
                        /**
                         * The trend value for the success rate.
                         */
                        success_rate: number;
                        /**
                         * Trend value for the 95th percentile duration for a workflow for a given time window.
                         */
                        p95_duration_secs: number;
                        /**
                         * Trend value for the 50th percentile duration for a workflow for a given time window.
                         */
                        median_duration_secs: number;
                        /**
                         * The trend value for total credits consumed.
                         */
                        total_credits_used: number;
                        /**
                         * trend for mean time to recovery (mean time between failures and their next success).
                         */
                        mttr: number;
                        /**
                         * Trend value for the average number of runs per day.
                         */
                        throughput: number;
                    };
                    /**
                     * A list of all the workflow names for a given project.
                     */
                    workflow_names: Array<(string)>;
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
    };
    '/insights/{project-slug}/workflows/{workflow-name}/test-metrics': {
        get: {
            req: GetProjectWorkflowTestMetricsData;
            res: {
                /**
                 * A list of test metrics by workflow
                 */
                '200': {
                    /**
                     * The average number of tests executed per run
                     */
                    average_test_count: number;
                    /**
                     * Metrics for the most frequently failing tests
                     */
                    most_failed_tests: Array<{
                        /**
                         * The 95th percentile duration, in seconds, among a group of test runs.
                         */
                        p95_duration: number;
                        /**
                         * The total number of times the test was run.
                         */
                        total_runs: number;
                        /**
                         * The class the test belongs to.
                         */
                        classname: string;
                        /**
                         * The number of times the test failed
                         */
                        failed_runs: number;
                        /**
                         * Whether the test is flaky.
                         */
                        flaky: boolean;
                        /**
                         * The source of the test.
                         */
                        source: string;
                        /**
                         * The file the test belongs to.
                         */
                        file: string;
                        /**
                         * The name of the job.
                         */
                        job_name: string;
                        /**
                         * The name of the test.
                         */
                        test_name: string;
                    }>;
                    /**
                     * The number of tests with the same success rate being omitted from most_failed_tests
                     */
                    most_failed_tests_extra: number;
                    /**
                     * Metrics for the slowest running tests
                     */
                    slowest_tests: Array<{
                        /**
                         * The 95th percentile duration, in seconds, among a group of test runs.
                         */
                        p95_duration: number;
                        /**
                         * The total number of times the test was run.
                         */
                        total_runs: number;
                        /**
                         * The class the test belongs to.
                         */
                        classname: string;
                        /**
                         * The number of times the test failed
                         */
                        failed_runs: number;
                        /**
                         * Whether the test is flaky.
                         */
                        flaky: boolean;
                        /**
                         * The source of the test.
                         */
                        source: string;
                        /**
                         * The file the test belongs to.
                         */
                        file: string;
                        /**
                         * The name of the job.
                         */
                        job_name: string;
                        /**
                         * The name of the test.
                         */
                        test_name: string;
                    }>;
                    /**
                     * The number of tests with the same duration rate being omitted from slowest_tests
                     */
                    slowest_tests_extra: number;
                    /**
                     * The total number of test runs
                     */
                    total_test_runs: number;
                    /**
                     * Test counts grouped by pipeline number and workflow id
                     */
                    test_runs: Array<{
                        /**
                         * The number of the pipeline associated with the provided test counts
                         */
                        pipeline_number: number;
                        /**
                         * The ID of the workflow associated with the provided test counts
                         */
                        workflow_id: unknown;
                        /**
                         * The success rate calculated from test counts
                         */
                        success_rate: number;
                        /**
                         * Test counts for a given pipeline number
                         */
                        test_counts: {
                            /**
                             * The number of tests with the error status
                             */
                            error: number;
                            /**
                             * The number of tests with the failure status
                             */
                            failure: number;
                            /**
                             * The number of tests with the skipped status
                             */
                            skipped: number;
                            /**
                             * The number of tests with the success status
                             */
                            success: number;
                            /**
                             * The total number of tests
                             */
                            total: number;
                        };
                    }>;
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
    };
    '/me': {
        get: {
            res: {
                /**
                 * User login information.
                 */
                '200': {
                    /**
                     * The unique ID of the user.
                     */
                    id: string;
                    /**
                     * The login information for the user on the VCS.
                     */
                    login: string;
                    /**
                     * The name of the user.
                     */
                    name: string;
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
    };
    '/me/collaborations': {
        get: {
            res: {
                /**
                 * Collaborations
                 */
                '200': Array<{
                    /**
                     * The UUID of the organization
                     */
                    id: string;
                    /**
                     * The VCS provider
                     */
                    'vcs-type': string;
                    /**
                     * The name of the organization
                     */
                    name: string;
                    /**
                     * URL to the user's avatar on the VCS
                     */
                    avatar_url: string;
                    /**
                     * The slug of the organization
                     */
                    slug: string;
                }>;
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
    };
    '/pipeline': {
        get: {
            req: ListPipelinesData;
            res: {
                /**
                 * A sequence of pipelines.
                 */
                '200': {
                    items: Array<{
                        /**
                         * The unique ID of the pipeline.
                         */
                        id: string;
                        /**
                         * A sequence of errors that have occurred within the pipeline.
                         */
                        errors: Array<{
                            /**
                             * The type of error.
                             */
                            type: 'config' | 'config-fetch' | 'timeout' | 'permission' | 'other' | 'trigger-rule' | 'plan';
                            /**
                             * A human-readable error message.
                             */
                            message: string;
                        }>;
                        /**
                         * The project-slug for the pipeline.
                         */
                        project_slug: string;
                        /**
                         * The date and time the pipeline was last updated.
                         */
                        updated_at?: string;
                        /**
                         * The number of the pipeline.
                         */
                        number: number;
                        trigger_parameters?: {
                            [key: string]: (string | number | boolean | {
    [key: string]: unknown;
});
                        };
                        /**
                         * The current state of the pipeline.
                         */
                        state: 'created' | 'errored' | 'setup-pending' | 'setup' | 'pending';
                        /**
                         * The date and time the pipeline was created.
                         */
                        created_at: string;
                        /**
                         * A summary of the trigger.
                         */
                        trigger: {
                            /**
                             * The type of trigger.
                             */
                            type: 'scheduled_pipeline' | 'explicit' | 'api' | 'webhook';
                            /**
                             * The date and time the trigger was received.
                             */
                            received_at: string;
                            /**
                             * The user who triggered the Pipeline.
                             */
                            actor: {
                                /**
                                 * The login information for the user on the VCS.
                                 */
                                login: string;
                                /**
                                 * URL to the user's avatar on the VCS
                                 */
                                avatar_url: string;
                            };
                        };
                        /**
                         * VCS information for the pipeline.
                         */
                        vcs?: {
                            /**
                             * Name of the VCS provider (e.g. GitHub, Bitbucket).
                             */
                            provider_name: string;
                            /**
                             * URL for the repository the trigger targets (i.e. the repository where the PR will be merged). For fork-PR pipelines, this is the URL to the parent repo. For other pipelines, the `origin_` and `target_repository_url`s will be the same.
                             */
                            target_repository_url: string;
                            /**
                             * The branch where the pipeline ran. The HEAD commit on this branch was used for the pipeline. Note that `branch` and `tag` are mutually exclusive. To trigger a pipeline for a PR by number use `pull/<number>/head` for the PR ref or `pull/<number>/merge` for the merge ref (GitHub only).
                             */
                            branch?: string;
                            /**
                             * The code review id.
                             */
                            review_id?: string;
                            /**
                             * The code review URL.
                             */
                            review_url?: string;
                            /**
                             * The code revision the pipeline ran.
                             */
                            revision: string;
                            /**
                             * The tag used by the pipeline. The commit that this tag points to was used for the pipeline. Note that `branch` and `tag` are mutually exclusive.
                             */
                            tag?: string;
                            /**
                             * The latest commit in the pipeline.
                             */
                            commit?: {
                                /**
                                 * The subject of the commit message.
                                 */
                                subject: string;
                                /**
                                 * The body of the commit message.
                                 */
                                body: string;
                            };
                            /**
                             * URL for the repository where the trigger originated. For fork-PR pipelines, this is the URL to the fork. For other pipelines the `origin_` and `target_repository_url`s will be the same.
                             */
                            origin_repository_url: string;
                        };
                    }>;
                    /**
                     * A token to pass as a `page-token` query parameter to return the next page of results.
                     */
                    next_page_token: string;
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
    };
    '/pipeline/continue': {
        post: {
            req: ContinuePipelineData;
            res: {
                /**
                 * A confirmation message.
                 */
                '200': {
                    /**
                     * A human-readable message
                     */
                    message: string;
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
    };
    '/pipeline/{pipeline-id}': {
        get: {
            req: GetPipelineByIdData;
            res: {
                /**
                 * A pipeline object.
                 */
                '200': {
                    /**
                     * The unique ID of the pipeline.
                     */
                    id: string;
                    /**
                     * A sequence of errors that have occurred within the pipeline.
                     */
                    errors: Array<{
                        /**
                         * The type of error.
                         */
                        type: 'config' | 'config-fetch' | 'timeout' | 'permission' | 'other' | 'trigger-rule' | 'plan';
                        /**
                         * A human-readable error message.
                         */
                        message: string;
                    }>;
                    /**
                     * The project-slug for the pipeline.
                     */
                    project_slug: string;
                    /**
                     * The date and time the pipeline was last updated.
                     */
                    updated_at?: string;
                    /**
                     * The number of the pipeline.
                     */
                    number: number;
                    trigger_parameters?: {
                        [key: string]: (string | number | boolean | {
    [key: string]: unknown;
});
                    };
                    /**
                     * The current state of the pipeline.
                     */
                    state: 'created' | 'errored' | 'setup-pending' | 'setup' | 'pending';
                    /**
                     * The date and time the pipeline was created.
                     */
                    created_at: string;
                    /**
                     * A summary of the trigger.
                     */
                    trigger: {
                        /**
                         * The type of trigger.
                         */
                        type: 'scheduled_pipeline' | 'explicit' | 'api' | 'webhook';
                        /**
                         * The date and time the trigger was received.
                         */
                        received_at: string;
                        /**
                         * The user who triggered the Pipeline.
                         */
                        actor: {
                            /**
                             * The login information for the user on the VCS.
                             */
                            login: string;
                            /**
                             * URL to the user's avatar on the VCS
                             */
                            avatar_url: string;
                        };
                    };
                    /**
                     * VCS information for the pipeline.
                     */
                    vcs?: {
                        /**
                         * Name of the VCS provider (e.g. GitHub, Bitbucket).
                         */
                        provider_name: string;
                        /**
                         * URL for the repository the trigger targets (i.e. the repository where the PR will be merged). For fork-PR pipelines, this is the URL to the parent repo. For other pipelines, the `origin_` and `target_repository_url`s will be the same.
                         */
                        target_repository_url: string;
                        /**
                         * The branch where the pipeline ran. The HEAD commit on this branch was used for the pipeline. Note that `branch` and `tag` are mutually exclusive. To trigger a pipeline for a PR by number use `pull/<number>/head` for the PR ref or `pull/<number>/merge` for the merge ref (GitHub only).
                         */
                        branch?: string;
                        /**
                         * The code review id.
                         */
                        review_id?: string;
                        /**
                         * The code review URL.
                         */
                        review_url?: string;
                        /**
                         * The code revision the pipeline ran.
                         */
                        revision: string;
                        /**
                         * The tag used by the pipeline. The commit that this tag points to was used for the pipeline. Note that `branch` and `tag` are mutually exclusive.
                         */
                        tag?: string;
                        /**
                         * The latest commit in the pipeline.
                         */
                        commit?: {
                            /**
                             * The subject of the commit message.
                             */
                            subject: string;
                            /**
                             * The body of the commit message.
                             */
                            body: string;
                        };
                        /**
                         * URL for the repository where the trigger originated. For fork-PR pipelines, this is the URL to the fork. For other pipelines the `origin_` and `target_repository_url`s will be the same.
                         */
                        origin_repository_url: string;
                    };
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
    };
    '/pipeline/{pipeline-id}/config': {
        get: {
            req: GetPipelineConfigByIdData;
            res: {
                /**
                 * The configuration strings for the pipeline.
                 */
                '200': {
                    /**
                     * The source configuration for the pipeline, before any config compilation has been performed. If there is no config, then this field will be empty.
                     */
                    source: string;
                    /**
                     * The compiled configuration for the pipeline, after all orb expansion has been performed. If there were errors processing the pipeline's configuration, then this field may be empty.
                     */
                    compiled: string;
                    /**
                     * The setup configuration for the pipeline used for Setup Workflows. If there were errors processing the pipeline's configuration or if setup workflows are not enabled, then this field should not exist
                     */
                    'setup-config'?: string;
                    /**
                     * The compiled setup configuration for the pipeline, after all orb expansion has been performed. If there were errors processing the pipeline's setup workflows, then this field may be empty.
                     */
                    'compiled-setup-config'?: string;
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
    };
    '/pipeline/{pipeline-id}/workflow': {
        get: {
            req: ListWorkflowsByPipelineIdData;
            res: {
                /**
                 * A paginated list of workflow objects.
                 */
                '200': {
                    /**
                     * A list of workflows.
                     */
                    items: Array<{
                        /**
                         * The ID of the pipeline this workflow belongs to.
                         */
                        pipeline_id: string;
                        canceled_by?: string;
                        /**
                         * The unique ID of the workflow.
                         */
                        id: string;
                        /**
                         * The name of the workflow.
                         */
                        name: string;
                        /**
                         * The project-slug for the pipeline this workflow belongs to.
                         */
                        project_slug: string;
                        errored_by?: string;
                        /**
                         * Tag used for the workflow
                         */
                        tag?: 'setup';
                        /**
                         * The current status of the workflow.
                         */
                        status: 'success' | 'running' | 'not_run' | 'failed' | 'error' | 'failing' | 'on_hold' | 'canceled' | 'unauthorized';
                        started_by: string;
                        /**
                         * The number of the pipeline this workflow belongs to.
                         */
                        pipeline_number: number;
                        /**
                         * The date and time the workflow was created.
                         */
                        created_at: string;
                        /**
                         * The date and time the workflow stopped.
                         */
                        stopped_at: string;
                    }>;
                    /**
                     * A token to pass as a `page-token` query parameter to return the next page of results.
                     */
                    next_page_token: string;
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
    };
    '/project/{project-slug}': {
        get: {
            req: GetProjectBySlugData;
            res: {
                /**
                 * A project object
                 */
                '200': {
                    /**
                     * Project slug in the form `vcs-slug/org-name/repo-name`. The `/` characters may be URL-escaped. For projects that use GitLab or GitHub App, use `circleci` as the `vcs-slug`, replace `org-name` with the organization ID (found in Organization Settings), and replace `repo-name` with the project ID (found in Project Settings).
                     */
                    slug: string;
                    /**
                     * The name of the project
                     */
                    name: string;
                    id: string;
                    /**
                     * The name of the organization the project belongs to
                     */
                    organization_name: string;
                    /**
                     * The slug of the organization the project belongs to
                     */
                    organization_slug: string;
                    /**
                     * The id of the organization the project belongs to
                     */
                    organization_id: string;
                    /**
                     * Information about the VCS that hosts the project source code.
                     */
                    vcs_info: {
                        /**
                         * URL to the repository hosting the project's code
                         */
                        vcs_url: string;
                        /**
                         * The VCS provider
                         */
                        provider: 'Bitbucket' | 'CircleCI' | 'GitHub';
                        default_branch: string;
                    };
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
    };
    '/project/{project-slug}/checkout-key': {
        post: {
            req: CreateCheckoutKeyData;
            res: {
                /**
                 * The checkout key.
                 */
                '201': {
                    /**
                     * A public SSH key.
                     */
                    'public-key': string;
                    /**
                     * The type of checkout key. This may be either `deploy-key` or `github-user-key`.
                     */
                    type: 'deploy-key' | 'github-user-key';
                    /**
                     * An SSH key fingerprint.
                     */
                    fingerprint: string;
                    /**
                     * A boolean value that indicates if this key is preferred.
                     */
                    preferred: boolean;
                    /**
                     * The date and time the checkout key was created.
                     */
                    'created-at': string;
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
        get: {
            req: ListCheckoutKeysData;
            res: {
                /**
                 * A sequence of checkout keys.
                 */
                '200': {
                    items: Array<{
                        /**
                         * A public SSH key.
                         */
                        'public-key': string;
                        /**
                         * The type of checkout key. This may be either `deploy-key` or `github-user-key`.
                         */
                        type: 'deploy-key' | 'github-user-key';
                        /**
                         * An SSH key fingerprint.
                         */
                        fingerprint: string;
                        /**
                         * A boolean value that indicates if this key is preferred.
                         */
                        preferred: boolean;
                        /**
                         * The date and time the checkout key was created.
                         */
                        'created-at': string;
                    }>;
                    /**
                     * A token to pass as a `page-token` query parameter to return the next page of results.
                     */
                    next_page_token: string;
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
    };
    '/project/{project-slug}/checkout-key/{fingerprint}': {
        delete: {
            req: DeleteCheckoutKeyData;
            res: {
                /**
                 * A confirmation message.
                 */
                '200': {
                    /**
                     * A human-readable message
                     */
                    message: string;
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
        get: {
            req: GetCheckoutKeyData;
            res: {
                /**
                 * The checkout key.
                 */
                '200': {
                    /**
                     * A public SSH key.
                     */
                    'public-key': string;
                    /**
                     * The type of checkout key. This may be either `deploy-key` or `github-user-key`.
                     */
                    type: 'deploy-key' | 'github-user-key';
                    /**
                     * An SSH key fingerprint.
                     */
                    fingerprint: string;
                    /**
                     * A boolean value that indicates if this key is preferred.
                     */
                    preferred: boolean;
                    /**
                     * The date and time the checkout key was created.
                     */
                    'created-at': string;
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
    };
    '/project/{project-slug}/envvar': {
        get: {
            req: ListEnvVarsData;
            res: {
                /**
                 * A sequence of environment variables.
                 */
                '200': {
                    items: Array<{
                        /**
                         * The name of the environment variable.
                         */
                        name: string;
                        /**
                         * The value of the environment variable.
                         */
                        value: string;
                        /**
                         * The creation timestamp of the environment variable.
                         */
                        'created-at'?: unknown;
                    }>;
                    /**
                     * A token to pass as a `page-token` query parameter to return the next page of results.
                     */
                    next_page_token: string;
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
        post: {
            req: CreateEnvVarData;
            res: {
                /**
                 * The environment variable.
                 */
                '201': {
                    /**
                     * The name of the environment variable.
                     */
                    name: string;
                    /**
                     * The value of the environment variable.
                     */
                    value: string;
                    /**
                     * The creation timestamp of the environment variable.
                     */
                    'created-at'?: unknown;
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
    };
    '/project/{project-slug}/envvar/{name}': {
        delete: {
            req: DeleteEnvVarData;
            res: {
                /**
                 * A confirmation message.
                 */
                '200': {
                    /**
                     * A human-readable message
                     */
                    message: string;
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
        get: {
            req: GetEnvVarData;
            res: {
                /**
                 * The environment variable.
                 */
                '200': {
                    /**
                     * The name of the environment variable.
                     */
                    name: string;
                    /**
                     * The value of the environment variable.
                     */
                    value: string;
                    /**
                     * The creation timestamp of the environment variable.
                     */
                    'created-at'?: unknown;
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
    };
    '/project/{project-slug}/job/{job-number}': {
        get: {
            req: GetJobDetailsData;
            res: {
                /**
                 * Job details.
                 */
                '200': {
                    /**
                     * URL of the job in CircleCI Web UI.
                     */
                    web_url: string;
                    /**
                     * Information about a project.
                     */
                    project: {
                        id: string;
                        /**
                         * Project slug in the form `vcs-slug/org-name/repo-name`. The `/` characters may be URL-escaped. For projects that use GitLab or GitHub App, use `circleci` as the `vcs-slug`, replace `org-name` with the organization ID (found in Organization Settings), and replace `repo-name` with the project ID (found in Project Settings).
                         */
                        slug: string;
                        /**
                         * The name of the project
                         */
                        name: string;
                        /**
                         * URL to the repository hosting the project's code
                         */
                        external_url: string;
                    };
                    /**
                     * Info about parallels runs and their status.
                     */
                    parallel_runs: Array<{
                        /**
                         * Index of the parallel run.
                         */
                        index: number;
                        /**
                         * Status of the parallel run.
                         */
                        status: string;
                    }>;
                    /**
                     * The date and time the job started.
                     */
                    started_at: string;
                    /**
                     * Info about the latest workflow the job was a part of.
                     */
                    latest_workflow: {
                        /**
                         * The unique ID of the workflow.
                         */
                        id: string;
                        /**
                         * The name of the workflow.
                         */
                        name: string;
                    };
                    /**
                     * The name of the job.
                     */
                    name: string;
                    /**
                     * Information about executor used for a job.
                     */
                    executor: {
                        /**
                         * Resource class name.
                         */
                        resource_class: string;
                        /**
                         * Executor type.
                         */
                        type?: string;
                    };
                    /**
                     * A number of parallel runs the job has.
                     */
                    parallelism: number;
                    /**
                     * The current status of the job.
                     */
                    status: 'success' | 'running' | 'not_run' | 'failed' | 'retried' | 'queued' | 'not_running' | 'infrastructure_fail' | 'timedout' | 'on_hold' | 'terminated-unknown' | 'blocked' | 'canceled' | 'unauthorized';
                    /**
                     * The number of the job.
                     */
                    number: number;
                    /**
                     * Info about a pipeline the job is a part of.
                     */
                    pipeline: {
                        /**
                         * The unique ID of the pipeline.
                         */
                        id: string;
                    };
                    /**
                     * Duration of a job in milliseconds.
                     */
                    duration: number;
                    /**
                     * The time when the job was created.
                     */
                    created_at: string;
                    /**
                     * Messages from CircleCI execution platform.
                     */
                    messages: Array<{
                        /**
                         * Message type.
                         */
                        type: string;
                        /**
                         * Information describing message.
                         */
                        message: string;
                        /**
                         * Value describing the reason for message to be added to the job.
                         */
                        reason?: string;
                    }>;
                    /**
                     * List of contexts used by the job.
                     */
                    contexts: Array<{
                        /**
                         * The name of the context.
                         */
                        name: string;
                    }>;
                    /**
                     * Information about an organization.
                     */
                    organization: {
                        /**
                         * The name of the organization.
                         */
                        name: string;
                    };
                    /**
                     * The time when the job was placed in a queue.
                     */
                    queued_at: string;
                    /**
                     * The time when the job stopped.
                     */
                    stopped_at?: string;
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
    };
    '/project/{project-slug}/job/{job-number}/cancel': {
        post: {
            req: CancelJobData;
            res: {
                '200': {
                    /**
                     * A human-readable message
                     */
                    message: string;
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
    };
    '/project/{project-slug}/pipeline': {
        get: {
            req: ListPipelinesForProjectData;
            res: {
                /**
                 * A sequence of pipelines.
                 */
                '200': {
                    items: Array<{
                        /**
                         * The unique ID of the pipeline.
                         */
                        id: string;
                        /**
                         * A sequence of errors that have occurred within the pipeline.
                         */
                        errors: Array<{
                            /**
                             * The type of error.
                             */
                            type: 'config' | 'config-fetch' | 'timeout' | 'permission' | 'other' | 'trigger-rule' | 'plan';
                            /**
                             * A human-readable error message.
                             */
                            message: string;
                        }>;
                        /**
                         * The project-slug for the pipeline.
                         */
                        project_slug: string;
                        /**
                         * The date and time the pipeline was last updated.
                         */
                        updated_at?: string;
                        /**
                         * The number of the pipeline.
                         */
                        number: number;
                        trigger_parameters?: {
                            [key: string]: (string | number | boolean | {
    [key: string]: unknown;
});
                        };
                        /**
                         * The current state of the pipeline.
                         */
                        state: 'created' | 'errored' | 'setup-pending' | 'setup' | 'pending';
                        /**
                         * The date and time the pipeline was created.
                         */
                        created_at: string;
                        /**
                         * A summary of the trigger.
                         */
                        trigger: {
                            /**
                             * The type of trigger.
                             */
                            type: 'scheduled_pipeline' | 'explicit' | 'api' | 'webhook';
                            /**
                             * The date and time the trigger was received.
                             */
                            received_at: string;
                            /**
                             * The user who triggered the Pipeline.
                             */
                            actor: {
                                /**
                                 * The login information for the user on the VCS.
                                 */
                                login: string;
                                /**
                                 * URL to the user's avatar on the VCS
                                 */
                                avatar_url: string;
                            };
                        };
                        /**
                         * VCS information for the pipeline.
                         */
                        vcs?: {
                            /**
                             * Name of the VCS provider (e.g. GitHub, Bitbucket).
                             */
                            provider_name: string;
                            /**
                             * URL for the repository the trigger targets (i.e. the repository where the PR will be merged). For fork-PR pipelines, this is the URL to the parent repo. For other pipelines, the `origin_` and `target_repository_url`s will be the same.
                             */
                            target_repository_url: string;
                            /**
                             * The branch where the pipeline ran. The HEAD commit on this branch was used for the pipeline. Note that `branch` and `tag` are mutually exclusive. To trigger a pipeline for a PR by number use `pull/<number>/head` for the PR ref or `pull/<number>/merge` for the merge ref (GitHub only).
                             */
                            branch?: string;
                            /**
                             * The code review id.
                             */
                            review_id?: string;
                            /**
                             * The code review URL.
                             */
                            review_url?: string;
                            /**
                             * The code revision the pipeline ran.
                             */
                            revision: string;
                            /**
                             * The tag used by the pipeline. The commit that this tag points to was used for the pipeline. Note that `branch` and `tag` are mutually exclusive.
                             */
                            tag?: string;
                            /**
                             * The latest commit in the pipeline.
                             */
                            commit?: {
                                /**
                                 * The subject of the commit message.
                                 */
                                subject: string;
                                /**
                                 * The body of the commit message.
                                 */
                                body: string;
                            };
                            /**
                             * URL for the repository where the trigger originated. For fork-PR pipelines, this is the URL to the fork. For other pipelines the `origin_` and `target_repository_url`s will be the same.
                             */
                            origin_repository_url: string;
                        };
                    }>;
                    /**
                     * A token to pass as a `page-token` query parameter to return the next page of results.
                     */
                    next_page_token: string;
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
        post: {
            req: TriggerPipelineData;
            res: {
                /**
                 * The created pipeline.
                 */
                '201': {
                    /**
                     * The unique ID of the pipeline.
                     */
                    id: string;
                    /**
                     * The current state of the pipeline.
                     */
                    state: 'created' | 'errored' | 'setup-pending' | 'setup' | 'pending';
                    /**
                     * The number of the pipeline.
                     */
                    number: number;
                    /**
                     * The date and time the pipeline was created.
                     */
                    created_at: string;
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
    };
    '/project/{project-slug}/pipeline/mine': {
        get: {
            req: ListMyPipelinesData;
            res: {
                /**
                 * A sequence of pipelines.
                 */
                '200': {
                    items: Array<{
                        /**
                         * The unique ID of the pipeline.
                         */
                        id: string;
                        /**
                         * A sequence of errors that have occurred within the pipeline.
                         */
                        errors: Array<{
                            /**
                             * The type of error.
                             */
                            type: 'config' | 'config-fetch' | 'timeout' | 'permission' | 'other' | 'trigger-rule' | 'plan';
                            /**
                             * A human-readable error message.
                             */
                            message: string;
                        }>;
                        /**
                         * The project-slug for the pipeline.
                         */
                        project_slug: string;
                        /**
                         * The date and time the pipeline was last updated.
                         */
                        updated_at?: string;
                        /**
                         * The number of the pipeline.
                         */
                        number: number;
                        trigger_parameters?: {
                            [key: string]: (string | number | boolean | {
    [key: string]: unknown;
});
                        };
                        /**
                         * The current state of the pipeline.
                         */
                        state: 'created' | 'errored' | 'setup-pending' | 'setup' | 'pending';
                        /**
                         * The date and time the pipeline was created.
                         */
                        created_at: string;
                        /**
                         * A summary of the trigger.
                         */
                        trigger: {
                            /**
                             * The type of trigger.
                             */
                            type: 'scheduled_pipeline' | 'explicit' | 'api' | 'webhook';
                            /**
                             * The date and time the trigger was received.
                             */
                            received_at: string;
                            /**
                             * The user who triggered the Pipeline.
                             */
                            actor: {
                                /**
                                 * The login information for the user on the VCS.
                                 */
                                login: string;
                                /**
                                 * URL to the user's avatar on the VCS
                                 */
                                avatar_url: string;
                            };
                        };
                        /**
                         * VCS information for the pipeline.
                         */
                        vcs?: {
                            /**
                             * Name of the VCS provider (e.g. GitHub, Bitbucket).
                             */
                            provider_name: string;
                            /**
                             * URL for the repository the trigger targets (i.e. the repository where the PR will be merged). For fork-PR pipelines, this is the URL to the parent repo. For other pipelines, the `origin_` and `target_repository_url`s will be the same.
                             */
                            target_repository_url: string;
                            /**
                             * The branch where the pipeline ran. The HEAD commit on this branch was used for the pipeline. Note that `branch` and `tag` are mutually exclusive. To trigger a pipeline for a PR by number use `pull/<number>/head` for the PR ref or `pull/<number>/merge` for the merge ref (GitHub only).
                             */
                            branch?: string;
                            /**
                             * The code review id.
                             */
                            review_id?: string;
                            /**
                             * The code review URL.
                             */
                            review_url?: string;
                            /**
                             * The code revision the pipeline ran.
                             */
                            revision: string;
                            /**
                             * The tag used by the pipeline. The commit that this tag points to was used for the pipeline. Note that `branch` and `tag` are mutually exclusive.
                             */
                            tag?: string;
                            /**
                             * The latest commit in the pipeline.
                             */
                            commit?: {
                                /**
                                 * The subject of the commit message.
                                 */
                                subject: string;
                                /**
                                 * The body of the commit message.
                                 */
                                body: string;
                            };
                            /**
                             * URL for the repository where the trigger originated. For fork-PR pipelines, this is the URL to the fork. For other pipelines the `origin_` and `target_repository_url`s will be the same.
                             */
                            origin_repository_url: string;
                        };
                    }>;
                    /**
                     * A token to pass as a `page-token` query parameter to return the next page of results.
                     */
                    next_page_token: string;
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
    };
    '/project/{project-slug}/pipeline/{pipeline-number}': {
        get: {
            req: GetPipelineByNumberData;
            res: {
                /**
                 * A pipeline object.
                 */
                '200': {
                    /**
                     * The unique ID of the pipeline.
                     */
                    id: string;
                    /**
                     * A sequence of errors that have occurred within the pipeline.
                     */
                    errors: Array<{
                        /**
                         * The type of error.
                         */
                        type: 'config' | 'config-fetch' | 'timeout' | 'permission' | 'other' | 'trigger-rule' | 'plan';
                        /**
                         * A human-readable error message.
                         */
                        message: string;
                    }>;
                    /**
                     * The project-slug for the pipeline.
                     */
                    project_slug: string;
                    /**
                     * The date and time the pipeline was last updated.
                     */
                    updated_at?: string;
                    /**
                     * The number of the pipeline.
                     */
                    number: number;
                    trigger_parameters?: {
                        [key: string]: (string | number | boolean | {
    [key: string]: unknown;
});
                    };
                    /**
                     * The current state of the pipeline.
                     */
                    state: 'created' | 'errored' | 'setup-pending' | 'setup' | 'pending';
                    /**
                     * The date and time the pipeline was created.
                     */
                    created_at: string;
                    /**
                     * A summary of the trigger.
                     */
                    trigger: {
                        /**
                         * The type of trigger.
                         */
                        type: 'scheduled_pipeline' | 'explicit' | 'api' | 'webhook';
                        /**
                         * The date and time the trigger was received.
                         */
                        received_at: string;
                        /**
                         * The user who triggered the Pipeline.
                         */
                        actor: {
                            /**
                             * The login information for the user on the VCS.
                             */
                            login: string;
                            /**
                             * URL to the user's avatar on the VCS
                             */
                            avatar_url: string;
                        };
                    };
                    /**
                     * VCS information for the pipeline.
                     */
                    vcs?: {
                        /**
                         * Name of the VCS provider (e.g. GitHub, Bitbucket).
                         */
                        provider_name: string;
                        /**
                         * URL for the repository the trigger targets (i.e. the repository where the PR will be merged). For fork-PR pipelines, this is the URL to the parent repo. For other pipelines, the `origin_` and `target_repository_url`s will be the same.
                         */
                        target_repository_url: string;
                        /**
                         * The branch where the pipeline ran. The HEAD commit on this branch was used for the pipeline. Note that `branch` and `tag` are mutually exclusive. To trigger a pipeline for a PR by number use `pull/<number>/head` for the PR ref or `pull/<number>/merge` for the merge ref (GitHub only).
                         */
                        branch?: string;
                        /**
                         * The code review id.
                         */
                        review_id?: string;
                        /**
                         * The code review URL.
                         */
                        review_url?: string;
                        /**
                         * The code revision the pipeline ran.
                         */
                        revision: string;
                        /**
                         * The tag used by the pipeline. The commit that this tag points to was used for the pipeline. Note that `branch` and `tag` are mutually exclusive.
                         */
                        tag?: string;
                        /**
                         * The latest commit in the pipeline.
                         */
                        commit?: {
                            /**
                             * The subject of the commit message.
                             */
                            subject: string;
                            /**
                             * The body of the commit message.
                             */
                            body: string;
                        };
                        /**
                         * URL for the repository where the trigger originated. For fork-PR pipelines, this is the URL to the fork. For other pipelines the `origin_` and `target_repository_url`s will be the same.
                         */
                        origin_repository_url: string;
                    };
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
    };
    '/project/{project-slug}/schedule': {
        post: {
            req: CreateScheduleData;
            res: {
                /**
                 * A schedule object.
                 */
                '201': {
                    /**
                     * The unique ID of the schedule.
                     */
                    id: string;
                    /**
                     * Timetable that specifies when a schedule triggers.
                     */
                    timetable: {
    /**
     * Number of times a schedule triggers per hour, value must be between 1 and 60
     */
    'per-hour': number;
    /**
     * Hours in a day in which the schedule triggers.
     */
    'hours-of-day': Array<(number)>;
    /**
     * Days in a week in which the schedule triggers.
     */
    'days-of-week': Array<('TUE' | 'SAT' | 'SUN' | 'MON' | 'THU' | 'WED' | 'FRI')>;
    /**
     * Days in a month in which the schedule triggers. This is mutually exclusive with days in a week.
     */
    'days-of-month'?: Array<(number)>;
    /**
     * Months in which the schedule triggers.
     */
    months?: Array<('MAR' | 'NOV' | 'DEC' | 'JUN' | 'MAY' | 'OCT' | 'FEB' | 'APR' | 'SEP' | 'AUG' | 'JAN' | 'JUL')>;
} | {
    /**
     * Number of times a schedule triggers per hour, value must be between 1 and 60
     */
    'per-hour': number;
    /**
     * Hours in a day in which the schedule triggers.
     */
    'hours-of-day': Array<(number)>;
    /**
     * Days in a month in which the schedule triggers. This is mutually exclusive with days in a week.
     */
    'days-of-month': Array<(number)>;
    /**
     * Days in a week in which the schedule triggers.
     */
    'days-of-week'?: Array<('TUE' | 'SAT' | 'SUN' | 'MON' | 'THU' | 'WED' | 'FRI')>;
    /**
     * Months in which the schedule triggers.
     */
    months?: Array<('MAR' | 'NOV' | 'DEC' | 'JUN' | 'MAY' | 'OCT' | 'FEB' | 'APR' | 'SEP' | 'AUG' | 'JAN' | 'JUL')>;
};
                    /**
                     * The date and time the pipeline was last updated.
                     */
                    'updated-at': string;
                    /**
                     * Name of the schedule.
                     */
                    name: string;
                    /**
                     * The date and time the pipeline was created.
                     */
                    'created-at': string;
                    /**
                     * The project-slug for the schedule
                     */
                    'project-slug': string;
                    /**
                     * Pipeline parameters represented as key-value pairs. Must contain branch or tag.
                     */
                    parameters: {
                        [key: string]: (number | string | boolean);
                    };
                    /**
                     * The attribution actor who will run the scheduled pipeline.
                     */
                    actor: {
                        /**
                         * The unique ID of the user.
                         */
                        id: string;
                        /**
                         * The login information for the user on the VCS.
                         */
                        login: string;
                        /**
                         * The name of the user.
                         */
                        name: string;
                    };
                    /**
                     * Description of the schedule.
                     */
                    description: string;
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
        get: {
            req: ListSchedulesForProjectData;
            res: {
                /**
                 * A sequence of schedules.
                 */
                '200': {
                    items: Array<{
                        /**
                         * The unique ID of the schedule.
                         */
                        id: string;
                        /**
                         * Timetable that specifies when a schedule triggers.
                         */
                        timetable: {
    /**
     * Number of times a schedule triggers per hour, value must be between 1 and 60
     */
    'per-hour': number;
    /**
     * Hours in a day in which the schedule triggers.
     */
    'hours-of-day': Array<(number)>;
    /**
     * Days in a week in which the schedule triggers.
     */
    'days-of-week': Array<('TUE' | 'SAT' | 'SUN' | 'MON' | 'THU' | 'WED' | 'FRI')>;
    /**
     * Days in a month in which the schedule triggers. This is mutually exclusive with days in a week.
     */
    'days-of-month'?: Array<(number)>;
    /**
     * Months in which the schedule triggers.
     */
    months?: Array<('MAR' | 'NOV' | 'DEC' | 'JUN' | 'MAY' | 'OCT' | 'FEB' | 'APR' | 'SEP' | 'AUG' | 'JAN' | 'JUL')>;
} | {
    /**
     * Number of times a schedule triggers per hour, value must be between 1 and 60
     */
    'per-hour': number;
    /**
     * Hours in a day in which the schedule triggers.
     */
    'hours-of-day': Array<(number)>;
    /**
     * Days in a month in which the schedule triggers. This is mutually exclusive with days in a week.
     */
    'days-of-month': Array<(number)>;
    /**
     * Days in a week in which the schedule triggers.
     */
    'days-of-week'?: Array<('TUE' | 'SAT' | 'SUN' | 'MON' | 'THU' | 'WED' | 'FRI')>;
    /**
     * Months in which the schedule triggers.
     */
    months?: Array<('MAR' | 'NOV' | 'DEC' | 'JUN' | 'MAY' | 'OCT' | 'FEB' | 'APR' | 'SEP' | 'AUG' | 'JAN' | 'JUL')>;
};
                        /**
                         * The date and time the pipeline was last updated.
                         */
                        'updated-at': string;
                        /**
                         * Name of the schedule.
                         */
                        name: string;
                        /**
                         * The date and time the pipeline was created.
                         */
                        'created-at': string;
                        /**
                         * The project-slug for the schedule
                         */
                        'project-slug': string;
                        /**
                         * Pipeline parameters represented as key-value pairs. Must contain branch or tag.
                         */
                        parameters: {
                            [key: string]: (number | string | boolean);
                        };
                        /**
                         * The attribution actor who will run the scheduled pipeline.
                         */
                        actor: {
                            /**
                             * The unique ID of the user.
                             */
                            id: string;
                            /**
                             * The login information for the user on the VCS.
                             */
                            login: string;
                            /**
                             * The name of the user.
                             */
                            name: string;
                        };
                        /**
                         * Description of the schedule.
                         */
                        description: string;
                    }>;
                    /**
                     * A token to pass as a `page-token` query parameter to return the next page of results.
                     */
                    next_page_token: string;
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
    };
    '/project/{project-slug}/{job-number}/artifacts': {
        get: {
            req: GetJobArtifactsData;
            res: {
                /**
                 * A paginated list of the job's artifacts.
                 */
                '200': {
                    items: Array<{
                        /**
                         * The artifact path.
                         */
                        path: string;
                        /**
                         * The index of the node that stored the artifact.
                         */
                        node_index: number;
                        /**
                         * The URL to download the artifact contents.
                         */
                        url: string;
                    }>;
                    /**
                     * A token to pass as a `page-token` query parameter to return the next page of results.
                     */
                    next_page_token: string;
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
    };
    '/project/{project-slug}/{job-number}/tests': {
        get: {
            req: GetTestsData;
            res: {
                /**
                 * A paginated list of test results.
                 */
                '200': {
                    items: Array<{
                        /**
                         * The failure message associated with the test.
                         */
                        message: string;
                        /**
                         * The program that generated the test results
                         */
                        source: string;
                        /**
                         * The time it took to run the test in seconds
                         */
                        run_time: number;
                        /**
                         * The file in which the test is defined.
                         */
                        file: string;
                        /**
                         * Indication of whether the test succeeded.
                         */
                        result: string;
                        /**
                         * The name of the test.
                         */
                        name: string;
                        /**
                         * The programmatic location of the test.
                         */
                        classname: string;
                    }>;
                    /**
                     * A token to pass as a `page-token` query parameter to return the next page of results.
                     */
                    next_page_token: string;
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
    };
    '/schedule/{schedule-id}': {
        delete: {
            req: DeleteScheduleByIdData;
            res: {
                /**
                 * A confirmation message.
                 */
                '200': {
                    /**
                     * A human-readable message
                     */
                    message: string;
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
        patch: {
            req: UpdateScheduleData;
            res: {
                /**
                 * A schedule object.
                 */
                '200': {
                    /**
                     * The unique ID of the schedule.
                     */
                    id: string;
                    /**
                     * Timetable that specifies when a schedule triggers.
                     */
                    timetable: {
    /**
     * Number of times a schedule triggers per hour, value must be between 1 and 60
     */
    'per-hour': number;
    /**
     * Hours in a day in which the schedule triggers.
     */
    'hours-of-day': Array<(number)>;
    /**
     * Days in a week in which the schedule triggers.
     */
    'days-of-week': Array<('TUE' | 'SAT' | 'SUN' | 'MON' | 'THU' | 'WED' | 'FRI')>;
    /**
     * Days in a month in which the schedule triggers. This is mutually exclusive with days in a week.
     */
    'days-of-month'?: Array<(number)>;
    /**
     * Months in which the schedule triggers.
     */
    months?: Array<('MAR' | 'NOV' | 'DEC' | 'JUN' | 'MAY' | 'OCT' | 'FEB' | 'APR' | 'SEP' | 'AUG' | 'JAN' | 'JUL')>;
} | {
    /**
     * Number of times a schedule triggers per hour, value must be between 1 and 60
     */
    'per-hour': number;
    /**
     * Hours in a day in which the schedule triggers.
     */
    'hours-of-day': Array<(number)>;
    /**
     * Days in a month in which the schedule triggers. This is mutually exclusive with days in a week.
     */
    'days-of-month': Array<(number)>;
    /**
     * Days in a week in which the schedule triggers.
     */
    'days-of-week'?: Array<('TUE' | 'SAT' | 'SUN' | 'MON' | 'THU' | 'WED' | 'FRI')>;
    /**
     * Months in which the schedule triggers.
     */
    months?: Array<('MAR' | 'NOV' | 'DEC' | 'JUN' | 'MAY' | 'OCT' | 'FEB' | 'APR' | 'SEP' | 'AUG' | 'JAN' | 'JUL')>;
};
                    /**
                     * The date and time the pipeline was last updated.
                     */
                    'updated-at': string;
                    /**
                     * Name of the schedule.
                     */
                    name: string;
                    /**
                     * The date and time the pipeline was created.
                     */
                    'created-at': string;
                    /**
                     * The project-slug for the schedule
                     */
                    'project-slug': string;
                    /**
                     * Pipeline parameters represented as key-value pairs. Must contain branch or tag.
                     */
                    parameters: {
                        [key: string]: (number | string | boolean);
                    };
                    /**
                     * The attribution actor who will run the scheduled pipeline.
                     */
                    actor: {
                        /**
                         * The unique ID of the user.
                         */
                        id: string;
                        /**
                         * The login information for the user on the VCS.
                         */
                        login: string;
                        /**
                         * The name of the user.
                         */
                        name: string;
                    };
                    /**
                     * Description of the schedule.
                     */
                    description: string;
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
        get: {
            req: GetScheduleByIdData;
            res: {
                /**
                 * A schedule object.
                 */
                '200': {
                    /**
                     * The unique ID of the schedule.
                     */
                    id: string;
                    /**
                     * Timetable that specifies when a schedule triggers.
                     */
                    timetable: {
    /**
     * Number of times a schedule triggers per hour, value must be between 1 and 60
     */
    'per-hour': number;
    /**
     * Hours in a day in which the schedule triggers.
     */
    'hours-of-day': Array<(number)>;
    /**
     * Days in a week in which the schedule triggers.
     */
    'days-of-week': Array<('TUE' | 'SAT' | 'SUN' | 'MON' | 'THU' | 'WED' | 'FRI')>;
    /**
     * Days in a month in which the schedule triggers. This is mutually exclusive with days in a week.
     */
    'days-of-month'?: Array<(number)>;
    /**
     * Months in which the schedule triggers.
     */
    months?: Array<('MAR' | 'NOV' | 'DEC' | 'JUN' | 'MAY' | 'OCT' | 'FEB' | 'APR' | 'SEP' | 'AUG' | 'JAN' | 'JUL')>;
} | {
    /**
     * Number of times a schedule triggers per hour, value must be between 1 and 60
     */
    'per-hour': number;
    /**
     * Hours in a day in which the schedule triggers.
     */
    'hours-of-day': Array<(number)>;
    /**
     * Days in a month in which the schedule triggers. This is mutually exclusive with days in a week.
     */
    'days-of-month': Array<(number)>;
    /**
     * Days in a week in which the schedule triggers.
     */
    'days-of-week'?: Array<('TUE' | 'SAT' | 'SUN' | 'MON' | 'THU' | 'WED' | 'FRI')>;
    /**
     * Months in which the schedule triggers.
     */
    months?: Array<('MAR' | 'NOV' | 'DEC' | 'JUN' | 'MAY' | 'OCT' | 'FEB' | 'APR' | 'SEP' | 'AUG' | 'JAN' | 'JUL')>;
};
                    /**
                     * The date and time the pipeline was last updated.
                     */
                    'updated-at': string;
                    /**
                     * Name of the schedule.
                     */
                    name: string;
                    /**
                     * The date and time the pipeline was created.
                     */
                    'created-at': string;
                    /**
                     * The project-slug for the schedule
                     */
                    'project-slug': string;
                    /**
                     * Pipeline parameters represented as key-value pairs. Must contain branch or tag.
                     */
                    parameters: {
                        [key: string]: (number | string | boolean);
                    };
                    /**
                     * The attribution actor who will run the scheduled pipeline.
                     */
                    actor: {
                        /**
                         * The unique ID of the user.
                         */
                        id: string;
                        /**
                         * The login information for the user on the VCS.
                         */
                        login: string;
                        /**
                         * The name of the user.
                         */
                        name: string;
                    };
                    /**
                     * Description of the schedule.
                     */
                    description: string;
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
    };
    '/user/{id}': {
        get: {
            req: GetUserData;
            res: {
                /**
                 * User login information.
                 */
                '200': {
                    /**
                     * The unique ID of the user.
                     */
                    id: string;
                    /**
                     * The login information for the user on the VCS.
                     */
                    login: string;
                    /**
                     * The name of the user.
                     */
                    name: string;
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
    };
    '/webhook': {
        get: {
            req: GetWebhooksData;
            res: {
                /**
                 * A list of webhooks
                 */
                '200': {
                    items: Array<{
                        /**
                         * URL to deliver the webhook to. Note: protocol must be included as well (only https is supported)
                         */
                        url: string;
                        /**
                         * Whether to enforce TLS certificate verification when delivering the webhook
                         */
                        'verify-tls': boolean;
                        /**
                         * The unique ID of the webhook
                         */
                        id: string;
                        /**
                         * Masked value of the secret used to build an HMAC hash of the payload and passed as a header in the webhook request
                         */
                        'signing-secret': string;
                        /**
                         * The date and time the webhook was last updated.
                         */
                        'updated-at': string;
                        /**
                         * Name of the webhook
                         */
                        name: string;
                        /**
                         * The date and time the webhook was created.
                         */
                        'created-at': string;
                        /**
                         * The scope in which the relevant events that will trigger webhooks
                         */
                        scope: {
                            /**
                             * ID of the scope being used (at the moment, only project ID is supported)
                             */
                            id: string;
                            /**
                             * Type of the scope being used
                             */
                            type: string;
                        };
                        /**
                         * Events that will trigger the webhook
                         */
                        events: Array<('workflow-completed' | 'job-completed')>;
                    }>;
                    /**
                     * A token to pass as a `page-token` query parameter to return the next page of results.
                     */
                    next_page_token: string;
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
        post: {
            req: CreateWebhookData;
            res: {
                /**
                 * A webhook
                 */
                '201': {
                    /**
                     * URL to deliver the webhook to. Note: protocol must be included as well (only https is supported)
                     */
                    url: string;
                    /**
                     * Whether to enforce TLS certificate verification when delivering the webhook
                     */
                    'verify-tls': boolean;
                    /**
                     * The unique ID of the webhook
                     */
                    id: string;
                    /**
                     * Masked value of the secret used to build an HMAC hash of the payload and passed as a header in the webhook request
                     */
                    'signing-secret': string;
                    /**
                     * The date and time the webhook was last updated.
                     */
                    'updated-at': string;
                    /**
                     * Name of the webhook
                     */
                    name: string;
                    /**
                     * The date and time the webhook was created.
                     */
                    'created-at': string;
                    /**
                     * The scope in which the relevant events that will trigger webhooks
                     */
                    scope: {
                        /**
                         * ID of the scope being used (at the moment, only project ID is supported)
                         */
                        id: string;
                        /**
                         * Type of the scope being used
                         */
                        type: string;
                    };
                    /**
                     * Events that will trigger the webhook
                     */
                    events: Array<('workflow-completed' | 'job-completed')>;
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
    };
    '/webhook/{webhook-id}': {
        delete: {
            req: DeleteWebhookData;
            res: {
                /**
                 * A confirmation message
                 */
                '200': {
                    /**
                     * A human-readable message
                     */
                    message: string;
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
        get: {
            req: GetWebhookByIdData;
            res: {
                /**
                 * A webhook
                 */
                '200': {
                    /**
                     * URL to deliver the webhook to. Note: protocol must be included as well (only https is supported)
                     */
                    url: string;
                    /**
                     * Whether to enforce TLS certificate verification when delivering the webhook
                     */
                    'verify-tls': boolean;
                    /**
                     * The unique ID of the webhook
                     */
                    id: string;
                    /**
                     * Masked value of the secret used to build an HMAC hash of the payload and passed as a header in the webhook request
                     */
                    'signing-secret': string;
                    /**
                     * The date and time the webhook was last updated.
                     */
                    'updated-at': string;
                    /**
                     * Name of the webhook
                     */
                    name: string;
                    /**
                     * The date and time the webhook was created.
                     */
                    'created-at': string;
                    /**
                     * The scope in which the relevant events that will trigger webhooks
                     */
                    scope: {
                        /**
                         * ID of the scope being used (at the moment, only project ID is supported)
                         */
                        id: string;
                        /**
                         * Type of the scope being used
                         */
                        type: string;
                    };
                    /**
                     * Events that will trigger the webhook
                     */
                    events: Array<('workflow-completed' | 'job-completed')>;
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
        put: {
            req: UpdateWebhookData;
            res: {
                /**
                 * A webhook
                 */
                '200': {
                    /**
                     * URL to deliver the webhook to. Note: protocol must be included as well (only https is supported)
                     */
                    url: string;
                    /**
                     * Whether to enforce TLS certificate verification when delivering the webhook
                     */
                    'verify-tls': boolean;
                    /**
                     * The unique ID of the webhook
                     */
                    id: string;
                    /**
                     * Masked value of the secret used to build an HMAC hash of the payload and passed as a header in the webhook request
                     */
                    'signing-secret': string;
                    /**
                     * The date and time the webhook was last updated.
                     */
                    'updated-at': string;
                    /**
                     * Name of the webhook
                     */
                    name: string;
                    /**
                     * The date and time the webhook was created.
                     */
                    'created-at': string;
                    /**
                     * The scope in which the relevant events that will trigger webhooks
                     */
                    scope: {
                        /**
                         * ID of the scope being used (at the moment, only project ID is supported)
                         */
                        id: string;
                        /**
                         * Type of the scope being used
                         */
                        type: string;
                    };
                    /**
                     * Events that will trigger the webhook
                     */
                    events: Array<('workflow-completed' | 'job-completed')>;
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
    };
    '/workflow/{id}': {
        get: {
            req: GetWorkflowByIdData;
            res: {
                /**
                 * A workflow object.
                 */
                '200': {
                    /**
                     * The ID of the pipeline this workflow belongs to.
                     */
                    pipeline_id: string;
                    canceled_by?: string;
                    /**
                     * The unique ID of the workflow.
                     */
                    id: string;
                    /**
                     * The name of the workflow.
                     */
                    name: string;
                    /**
                     * The project-slug for the pipeline this workflow belongs to.
                     */
                    project_slug: string;
                    errored_by?: string;
                    /**
                     * Tag used for the workflow
                     */
                    tag?: 'setup';
                    /**
                     * The current status of the workflow.
                     */
                    status: 'success' | 'running' | 'not_run' | 'failed' | 'error' | 'failing' | 'on_hold' | 'canceled' | 'unauthorized';
                    started_by: string;
                    /**
                     * The number of the pipeline this workflow belongs to.
                     */
                    pipeline_number: number;
                    /**
                     * The date and time the workflow was created.
                     */
                    created_at: string;
                    /**
                     * The date and time the workflow stopped.
                     */
                    stopped_at: string;
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
    };
    '/workflow/{id}/approve/{approval_request_id}': {
        post: {
            req: ApprovePendingApprovalJobByIdData;
            res: {
                /**
                 * A confirmation message.
                 */
                '202': {
                    /**
                     * A human-readable message
                     */
                    message: string;
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
    };
    '/workflow/{id}/cancel': {
        post: {
            req: CancelWorkflowData;
            res: {
                /**
                 * A confirmation message.
                 */
                '202': {
                    /**
                     * A human-readable message
                     */
                    message: string;
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
    };
    '/workflow/{id}/job': {
        get: {
            req: ListWorkflowJobsData;
            res: {
                /**
                 * A paginated sequence of jobs.
                 */
                '200': {
                    items: Array<{
                        /**
                         * The unique ID of the user.
                         */
                        canceled_by?: string;
                        /**
                         * A sequence of the unique job IDs for the jobs that this job depends upon in the workflow.
                         */
                        dependencies: Array<(string)>;
                        /**
                         * The number of the job.
                         */
                        job_number?: number;
                        /**
                         * The unique ID of the job.
                         */
                        id: string;
                        /**
                         * The date and time the job started.
                         */
                        started_at: string;
                        /**
                         * The name of the job.
                         */
                        name: string;
                        /**
                         * The unique ID of the user.
                         */
                        approved_by?: string;
                        /**
                         * The project-slug for the job.
                         */
                        project_slug: string;
                        /**
                         * The current status of the job.
                         */
                        status: 'success' | 'running' | 'not_run' | 'failed' | 'retried' | 'queued' | 'not_running' | 'infrastructure_fail' | 'timedout' | 'on_hold' | 'terminated-unknown' | 'blocked' | 'canceled' | 'unauthorized';
                        /**
                         * The type of job.
                         */
                        type: 'build' | 'approval';
                        /**
                         * The time when the job stopped.
                         */
                        stopped_at?: string;
                        /**
                         * The unique ID of the job.
                         */
                        approval_request_id?: string;
                    }>;
                    /**
                     * A token to pass as a `page-token` query parameter to return the next page of results.
                     */
                    next_page_token: string;
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
    };
    '/workflow/{id}/rerun': {
        post: {
            req: RerunWorkflowData;
            res: {
                /**
                 * A confirmation message.
                 */
                '202': {
                    /**
                     * The ID of the newly-created workflow.
                     */
                    workflow_id: string;
                };
                /**
                 * Error response.
                 */
                default: {
                    message?: string;
                };
            };
        };
    };
    '/org/{orgID}/oidc-custom-claims': {
        delete: {
            req: DeleteOrgClaimsData;
            res: {
                /**
                 * Claims successfully deleted.
                 */
                '200': ClaimResponse;
                /**
                 * The request is malformed (e.g, a given path parameter is invalid)
                 *
                 */
                '400': {
                    error: string;
                };
                /**
                 * The user is forbidden from making this request
                 *
                 */
                '403': {
                    error: string;
                };
                /**
                 * Something unexpected happened on the server.
                 */
                '500': {
                    error: string;
                };
            };
        };
        get: {
            req: GetOrgClaimsData;
            res: {
                /**
                 * Claims successfully fetched.
                 */
                '200': ClaimResponse;
                /**
                 * The request is malformed (e.g, a given path parameter is invalid)
                 *
                 */
                '400': {
                    error: string;
                };
                /**
                 * The user is forbidden from making this request
                 *
                 */
                '403': {
                    error: string;
                };
                /**
                 * Something unexpected happened on the server.
                 */
                '500': {
                    error: string;
                };
            };
        };
        patch: {
            req: PatchOrgClaimsData;
            res: {
                /**
                 * Claims successfully patched.
                 */
                '200': ClaimResponse;
                /**
                 * The request is malformed (e.g, a given path parameter is invalid)
                 *
                 */
                '400': {
                    error: string;
                };
                /**
                 * The user is forbidden from making this request
                 *
                 */
                '403': {
                    error: string;
                };
                /**
                 * Something unexpected happened on the server.
                 */
                '500': {
                    error: string;
                };
            };
        };
    };
    '/org/{orgID}/project/{projectID}/oidc-custom-claims': {
        delete: {
            req: DeleteProjectClaimsData;
            res: {
                /**
                 * Claims successfully deleted.
                 */
                '200': ClaimResponse;
                /**
                 * The request is malformed (e.g, a given path parameter is invalid)
                 *
                 */
                '400': {
                    error: string;
                };
                /**
                 * The user is forbidden from making this request
                 *
                 */
                '403': {
                    error: string;
                };
                /**
                 * Something unexpected happened on the server.
                 */
                '500': {
                    error: string;
                };
            };
        };
        get: {
            req: GetProjectClaimsData;
            res: {
                /**
                 * Claims successfully fetched.
                 */
                '200': ClaimResponse;
                /**
                 * The request is malformed (e.g, a given path parameter is invalid)
                 *
                 */
                '400': {
                    error: string;
                };
                /**
                 * The user is forbidden from making this request
                 *
                 */
                '403': {
                    error: string;
                };
                /**
                 * Something unexpected happened on the server.
                 */
                '500': {
                    error: string;
                };
            };
        };
        patch: {
            req: PatchProjectClaimsData;
            res: {
                /**
                 * Claims successfully patched.
                 */
                '200': ClaimResponse;
                /**
                 * The request is malformed (e.g, a given path parameter is invalid)
                 *
                 */
                '400': {
                    error: string;
                };
                /**
                 * The user is forbidden from making this request
                 *
                 */
                '403': {
                    error: string;
                };
                /**
                 * Something unexpected happened on the server.
                 */
                '500': {
                    error: string;
                };
            };
        };
    };
    '/owner/{ownerID}/context/{context}/decision': {
        get: {
            req: GetDecisionLogsData;
            res: {
                /**
                 * Decision logs successfully retrieved.
                 */
                '200': Array<DecisionLog>;
                /**
                 * The request is malformed (e.g, a given path parameter is invalid)
                 *
                 */
                '400': {
                    error: string;
                };
                /**
                 * The request is unauthorized
                 *
                 */
                '401': {
                    error: string;
                };
                /**
                 * The user is forbidden from making this request
                 *
                 */
                '403': {
                    error: string;
                };
                /**
                 * Something unexpected happened on the server.
                 */
                '500': {
                    error: string;
                };
            };
        };
        post: {
            req: MakeDecisionData;
            res: {
                /**
                 * Decision rendered by applying the policy against the provided data. Response will be modeled by the data and rego processed.
                 */
                '200': Decision;
                /**
                 * The request is malformed
                 *
                 */
                '400': {
                    error: string;
                };
                /**
                 * The request is unauthorized
                 *
                 */
                '401': {
                    error: string;
                };
                /**
                 * Something unexpected happened on the server.
                 */
                '500': {
                    error: string;
                };
            };
        };
    };
    '/owner/{ownerID}/context/{context}/decision/settings': {
        get: {
            req: GetDecisionSettingsData;
            res: {
                /**
                 * Decision settings successfully retrieved.
                 */
                '200': DecisionSettings;
                /**
                 * The request is malformed (e.g, a given path parameter is invalid)
                 *
                 */
                '400': {
                    error: string;
                };
                /**
                 * The request is unauthorized
                 *
                 */
                '401': {
                    error: string;
                };
                /**
                 * The user is forbidden from making this request
                 *
                 */
                '403': {
                    error: string;
                };
                /**
                 * Something unexpected happened on the server.
                 */
                '500': {
                    error: string;
                };
            };
        };
        patch: {
            req: SetDecisionSettingsData;
            res: {
                /**
                 * Decision settings successfully set.
                 */
                '200': DecisionSettings;
                /**
                 * The request is malformed (e.g, a given path parameter is invalid)
                 *
                 */
                '400': {
                    error: string;
                };
                /**
                 * The request is unauthorized
                 *
                 */
                '401': {
                    error: string;
                };
                /**
                 * The user is forbidden from making this request
                 *
                 */
                '403': {
                    error: string;
                };
                /**
                 * Something unexpected happened on the server.
                 */
                '500': {
                    error: string;
                };
            };
        };
    };
    '/owner/{ownerID}/context/{context}/decision/{decisionID}': {
        get: {
            req: GetDecisionLogData;
            res: {
                /**
                 * Decision log successfully retrieved.
                 */
                '200': DecisionLog;
                /**
                 * The request is malformed (e.g, a given path parameter is invalid)
                 *
                 */
                '400': {
                    error: string;
                };
                /**
                 * The request is unauthorized
                 *
                 */
                '401': {
                    error: string;
                };
                /**
                 * The user is forbidden from making this request
                 *
                 */
                '403': {
                    error: string;
                };
                /**
                 * There was no decision log found for given decision_id, and owner_id.
                 *
                 */
                '404': {
                    error: string;
                };
                /**
                 * Something unexpected happened on the server.
                 */
                '500': {
                    error: string;
                };
            };
        };
    };
    '/owner/{ownerID}/context/{context}/decision/{decisionID}/policy-bundle': {
        get: {
            req: GetDecisionLogPolicyBundleData;
            res: {
                /**
                 * Policy-Bundle retrieved successfully for given decision log ID
                 */
                '200': PolicyBundle;
                /**
                 * The request is malformed (e.g, a given path parameter is invalid)
                 *
                 */
                '400': {
                    error: string;
                };
                /**
                 * The request is unauthorized
                 *
                 */
                '401': {
                    error: string;
                };
                /**
                 * The user is forbidden from making this request
                 *
                 */
                '403': {
                    error: string;
                };
                /**
                 * There was no decision log found for given decision_id, and owner_id.
                 *
                 */
                '404': {
                    error: string;
                };
                /**
                 * Something unexpected happened on the server.
                 */
                '500': {
                    error: string;
                };
            };
        };
    };
    '/owner/{ownerID}/context/{context}/policy-bundle': {
        get: {
            req: GetPolicyBundleData;
            res: {
                /**
                 * Policy-Bundle retrieved successfully.
                 */
                '200': PolicyBundle;
                /**
                 * The request is malformed (e.g, a given path parameter is invalid)
                 *
                 */
                '400': {
                    error: string;
                };
                /**
                 * The request is unauthorized
                 *
                 */
                '401': {
                    error: string;
                };
                /**
                 * The user is forbidden from making this request
                 *
                 */
                '403': {
                    error: string;
                };
                /**
                 * Something unexpected happened on the server.
                 */
                '500': {
                    error: string;
                };
            };
        };
        post: {
            req: CreatePolicyBundleData;
            res: {
                /**
                 * Policy-Bundle diff successfully returned.
                 */
                '200': BundleDiff;
                /**
                 * Policy-Bundle successfully created.
                 */
                '201': BundleDiff;
                /**
                 * The request is malformed (e.g, a given path parameter is invalid)
                 *
                 */
                '400': {
                    error: string;
                };
                /**
                 * The request is unauthorized
                 *
                 */
                '401': {
                    error: string;
                };
                /**
                 * The user is forbidden from making this request
                 *
                 */
                '403': {
                    error: string;
                };
                /**
                 * The request exceeds the maximum payload size for policy bundles ~2.5Mib
                 *
                 */
                '413': {
                    error: string;
                };
                /**
                 * Something unexpected happened on the server.
                 */
                '500': {
                    error: string;
                };
            };
        };
    };
    '/owner/{ownerID}/context/{context}/policy-bundle/{policyName}': {
        get: {
            req: GetPolicyDocumentData;
            res: {
                /**
                 * Policy retrieved successfully.
                 */
                '200': Policy;
                /**
                 * The request is malformed (e.g, a given path parameter is invalid)
                 *
                 */
                '400': {
                    error: string;
                };
                /**
                 * The request is unauthorized
                 *
                 */
                '401': {
                    error: string;
                };
                /**
                 * The user is forbidden from making this request
                 *
                 */
                '403': {
                    error: string;
                };
                /**
                 * There was no policy that was found with the given owner_id and policy name.
                 *
                 */
                '404': {
                    error: string;
                };
                /**
                 * Something unexpected happened on the server.
                 */
                '500': {
                    error: string;
                };
            };
        };
    };
    '/context/{context_id}/restrictions': {
        get: {
            req: GetContextRestrictionsData;
            res: {
                /**
                 * Successful response.
                 */
                '200': context_project_restrictions_list;
                /**
                 * Context ID provided is invalid.
                 */
                '400': {
                    message?: string;
                };
                /**
                 * Credentials provided are invalid.
                 */
                '401': {
                    message?: string;
                };
                /**
                 * Entity not found.
                 */
                '404': {
                    message?: string;
                };
                /**
                 * API rate limits exceeded.
                 */
                '429': {
                    message?: string;
                };
                /**
                 * Internal server error.
                 */
                '500': {
                    message?: string;
                };
            };
        };
        post: {
            req: CreateContextRestrictionData;
            res: {
                /**
                 * Successful response.
                 */
                '201': restriction_created;
                /**
                 * Bad request.
                 */
                '400': {
                    message?: string;
                };
                /**
                 * Credentials provided are invalid.
                 */
                '401': {
                    message?: string;
                };
                /**
                 * Entity not found.
                 */
                '404': {
                    message?: string;
                };
                /**
                 * Request conflict.
                 */
                '409': {
                    message?: string;
                };
                /**
                 * API rate limits exceeded.
                 */
                '429': {
                    message?: string;
                };
                /**
                 * Internal server error.
                 */
                '500': {
                    message?: string;
                };
            };
        };
    };
    '/context/{context_id}/restrictions/{restriction_id}': {
        delete: {
            req: DeleteContextRestrictionData;
            res: {
                /**
                 * Successful response.
                 */
                '200': restriction_deleted;
                /**
                 * Context restriction ID provided is invalid.
                 */
                '400': {
                    message?: string;
                };
                /**
                 * Credentials provided are invalid.
                 */
                '401': {
                    message?: string;
                };
                /**
                 * Entity not found.
                 */
                '404': {
                    message?: string;
                };
                /**
                 * API rate limits exceeded.
                 */
                '429': {
                    message?: string;
                };
                /**
                 * Internal server error.
                 */
                '500': {
                    message?: string;
                };
            };
        };
    };
    '/project/{provider}/{organization}/{project}': {
        post: {
            req: CreateProjectData;
            res: {
                /**
                 * Successful response.
                 */
                '201': project_settings;
                /**
                 * Unexpected request body provided.
                 */
                '400': {
                    message?: string;
                };
                /**
                 * Credentials provided are invalid.
                 */
                '401': {
                    message?: string;
                };
                /**
                 * None or insufficient credentials provided.
                 */
                '403': {
                    message?: string;
                };
                /**
                 * Either a branch or a project were not found.
                 */
                '404': {
                    message?: string;
                };
                /**
                 * Create projects using the API is currently supported for classic Github OAuth and Bitbucket projects only.
                 */
                '405': {
                    message?: string;
                };
                /**
                 * API rate limits exceeded.
                 */
                '429': {
                    message?: string;
                };
                /**
                 * Internal server error.
                 */
                '500': {
                    message?: string;
                };
            };
        };
    };
    '/project/{provider}/{organization}/{project}/settings': {
        get: {
            req: GetProjectSettingsData;
            res: {
                /**
                 * Successful response.
                 */
                '200': project_settings;
                /**
                 * Credentials provided are invalid.
                 */
                '401': {
                    message?: string;
                };
                /**
                 * None or insufficient credentials provided.
                 */
                '403': {
                    message?: string;
                };
                /**
                 * Insufficient credentials for a private project, OR the organization, project, or repository does not exist.
                 */
                '404': {
                    message?: string;
                };
                /**
                 * API rate limits exceeded.
                 */
                '429': {
                    message?: string;
                };
                /**
                 * Internal server error.
                 */
                '500': {
                    message?: string;
                };
            };
        };
        patch: {
            req: PatchProjectSettingsData;
            res: {
                /**
                 * Successful response. Always includes the full advanced settings object. Returned even when the provided updates match the existing settings, but can also be returned when `oss: true` fails to set.
                 */
                '200': project_settings;
                /**
                 * Request is malformed, e.g. with improperly encoded JSON
                 */
                '400': {
                    message?: string;
                };
                /**
                 * Credentials provided are invalid.
                 */
                '401': {
                    message?: string;
                };
                /**
                 * None or insufficient credentials provided.
                 */
                '403': {
                    message?: string;
                };
                /**
                 * Insufficient credentials for a private project, OR the organization, project, or repository does not exist.
                 */
                '404': {
                    message?: string;
                };
                /**
                 * API rate limits exceeded.
                 */
                '429': {
                    message?: string;
                };
                /**
                 * Internal server error.
                 */
                '500': {
                    message?: string;
                };
            };
        };
    };
    '/organizations/{org_id}/usage_export_job': {
        post: {
            req: CreateUsageExportData;
            res: {
                /**
                 * Usage export created successfully
                 */
                '201': usage_export_job;
                /**
                 * Unexpected request body provided.
                 */
                '400': {
                    message?: string;
                };
                /**
                 * Credentials provided are invalid.
                 */
                '401': {
                    message?: string;
                };
                /**
                 * Entity not found.
                 */
                '404': {
                    message?: string;
                };
                /**
                 * API rate limits exceeded.
                 */
                '429': {
                    message?: string;
                };
                /**
                 * Internal server error.
                 */
                '500': {
                    message?: string;
                };
            };
        };
    };
    '/organizations/{org_id}/usage_export_job/{usage_export_job_id}': {
        get: {
            req: GetUsageExportData;
            res: {
                /**
                 * Usage export fetched successfully
                 */
                '200': get_usage_export_job_status;
                /**
                 * Unexpected request body provided.
                 */
                '400': {
                    message?: string;
                };
                /**
                 * Credentials provided are invalid.
                 */
                '401': {
                    message?: string;
                };
                /**
                 * Entity not found.
                 */
                '404': {
                    message?: string;
                };
                /**
                 * API rate limits exceeded.
                 */
                '429': {
                    message?: string;
                };
                /**
                 * Internal server error.
                 */
                '500': {
                    message?: string;
                };
            };
        };
    };
};